# -*- coding: utf-8 -*-
"""Test_game.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1mS_hCr2bc8lkTdmQoOniqdEmsVF3Aw3O
"""

import random
import json
import math
import numpy as np

null = None

"""# Characters"""

class PC:
    def __init__(self, Name, Combat_Class, Race, Eye_Color, Skin_Tone, Hair_Color, Size, Weight, Trademarks, STR, DEX, CON, INT, WIS, CHA, Muscle, Wrestle, Brawl, Jump, Coordination, Finesse, Sleight, Stealth, Endurance, Concentration, Vitality, Academic, Arcana, Culture, Search, Nature, Insight, Interaction, Medicine, Perception, Survival, Aggressive, Suave, Diplomatic, Sincere, Prime, Wounded, Bloodied, Offensive_Ability, Defensive_Ability, Movement_Ability, Special_Ability, Main_Hand, Off_Hand, Utility, Armor, Combat_Special_Move, Gold, Rations, Kits, Adventuring_Special_Moves, Value_Self, Value_Others, Value_Society, Mission, Interests, Talents, Quirks, Fears, Family, Friends, Professional, Nemesis, Factions, Home, Profession, Skill, Race_Bonus, Story, Roleplaying_Special_Moves, *Inventory): 
        # Basic information and appearance
        self.Name = Name
        self.Combat_Class = Combat_Class
        self.Race = Race
        self.Eye_Color = Eye_Color
        self.Skin_Tone = Skin_Tone
        self.Hair_Color = Hair_Color
        self.Size = Size
        self.Weight = Weight
        self.Trademarks = Trademarks

                # STATS and SKILLS
        self.Attributes_Base = {
            "STR": STR,
            "DEX": DEX,
            "CON": CON,
            "INT": INT,
            "WIS": WIS,
            "CHA": CHA
        }

        self.Attributes = {
            "STR": STR,
            "DEX": DEX,
            "CON": CON,
            "INT": INT,
            "WIS": WIS,
            "CHA": CHA
        }


        self.Skills_Base = {
            "Muscle": Muscle,
            "Wrestle": Wrestle,
            "Brawl": Brawl,
            "Jump": Jump,
            "Coordination": Coordination,
            "Finesse": Finesse,
            "Sleight": Sleight,
            "Stealth": Stealth,
            "Endurance": Endurance,
            "Concentration": Concentration,
            "Vitality": Vitality,
            "Academic": Academic,
            "Arcana": Arcana,
            "Culture":  Culture,
            "Search": Search,
            "Nature": Nature,
            "Insight": Insight,
            "Interaction": Interaction,
            "Medicine": Medicine,
            "Perception": Perception,
            "Survival": Survival,
            "Aggressive": Aggressive,
            "Suave": Suave,
            "Diplomatic": Diplomatic,
            "Sincere": Sincere
        }

        self.Skills = {
            "Muscle": Muscle,
            "Wrestle": Wrestle,
            "Brawl": Brawl,
            "Jump": Jump,
            "Coordination": Coordination,
            "Finesse": Finesse,
            "Sleight": Sleight,
            "Stealth": Stealth,
            "Endurance": Endurance,
            "Concentration": Concentration,
            "Vitality": Vitality,
            "Academic": Academic,
            "Arcana": Arcana,
            "Culture":  Culture,
            "Search": Search,
            "Nature": Nature,
            "Insight": Insight,
            "Interaction": Interaction,
            "Medicine": Medicine,
            "Perception": Perception,
            "Survival": Survival,
            "Aggressive": Aggressive,
            "Suave": Suave,
            "Diplomatic": Diplomatic,
            "Sincere": Sincere
        }
        
        #Health information

        self.Prime = Prime
        self.Wounded = Wounded
        self.Bloodied = Bloodied
        self.Max_HP = Prime + Wounded + Bloodied

        #base ap... should never change in battle
        self.Base_AP = 6
        self.Base_RP = 6
        self.Base_MP = 6

        #Max ap... is what is restored at the top of each turn and can change through out the battle
        self.Max_AP = 6
        self.Max_RP = 6
        self.Max_MP = 6
        self.Death_Saves = 0
        self.Death_Fails = 0

        self.Totals = {
            "Total":Prime + Wounded + Bloodied,
            "Prime":Prime, 
            "Wounded":Wounded, 
            "Bloodied":Bloodied
        }
        self.Stamina = "Prime"
        
        self.HP = {
            "Total":Prime + Wounded + Bloodied,
            "Prime":Prime, 
            "Wounded":Wounded, 
            "Bloodied":Bloodied
        }
        self.AP = 6
        self.RP = 6
        self.MP = 6

        
        #Statuses - always start at 0 and can be added during combat
        self.Statuses = {
            "Bleeding":0,
            "Blinded":0,
            "Crippled":0,
            "Deafened":0,
            "Fatigued":0,
            "Captivated":0,
            "Confused":0,
            "Frightened":0,
            "Stunned":0,
            "Unconscious":0,
            "Burning":0,
            "Impaled":0,
            "Momentum":0,
            "Prone":0,
            "Restrained":0,
            "Suffocating":0,
            "Surprised":0
        }

        self.Captivated_Source = {}
        self.Frightened_Source = {}


        #positions

        self.Location = {
            "x":0,
            "y":0,
            "z":0 
        }
        
        self.Positions = {
            "Cover":0,
            "Flanked":0,
            "Hidden":0,
            "High Ground":0,
            "Unbalanced":0
        }

        self.Direction = 0

        #we need to add dictionaries for every phase of the encounter both pre and post
        self.Open_Phase = {}
        self.Post_Open_Phase = {}
        self.Pre_Action = {}
        self.Post_Action = {}
        self.Pre_Reaction = {}
        self.Post_Reaction = {}
        self.Pre_Roll = {}
        self.Post_Roll = {}

        self.temp_bonus = 0
        self.misc_bonus = 0 
        self.crit_threshold = 20
        self.crit_fail_threshold = 1

        # Combat stats 
        # self.Attack_Bonus = Muscle + STR_Mod
        # self.Dodge_Bonus = Coordination + DEX_Mod
        # self.Defend_Bonus = Endurance + CON_Mod
        self.Offensive_Ability = Offensive_Ability
        self.Defensive_Ability = Defensive_Ability
        self.Movement_Ability = Movement_Ability
        self.Special_Ability = Special_Ability
        

        self.Power_Rank = 0

        #equipment
        self.Equipment = {
            "Main Hand":Main_Hand,
            "Off Hand":Off_Hand,
            "Utility":Utility,
            "Armor":Armor
        }

        self.Attack_Options = {}
        # self.Main_Hand = Main_Hand
        # self.Off_Hand = Off_Hand
        # self.Utility = Utility
        # self.Armor = Armor
        self.Combat_Special_Move = Combat_Special_Move

        # adventuring conditions - set at 0 until added to after combat or during adventuring
        self.Conditions = {
            "Bleeding":0,
            "Blinded":0,
            "Crippled":0,
            "Deafened":0,
            "Drowsy":0,
            "Fatigued":0,
            "Fractured":0,
            "Sickened":0
        }


        self.Short_Rest = 0
        self.Carry_Weight = 10
        self.Gold = Gold
        self.Rations = Rations
        self.Kits = Kits
        self.Adventuring_Special_Moves = Adventuring_Special_Moves


        self.Value_Self = Value_Self
        self.Value_Others = Value_Others
        self.Value_Society = Value_Society
        self.Mission = Mission
        self.Interests = Interests
        self.Talents = Talents
        self.Quirks = Quirks
        self.Fears = Fears
        self.Family = Family
        self.Friends = Friends
        self.Professional = Professional
        self.Nemesis = Nemesis
        self.Factions = Factions
        self.Home = Home
        self.Profession = Profession
        self.Skill = Skill
        self.Race_Bonus = Race_Bonus
        self.Story = Story
        self.Roleplaying_Special_Moves = Roleplaying_Special_Moves

        self.Inventory = Inventory

        def pack(Inventory):
          inventory_tuple = Inventory
          Backpack = []
          for i in inventory_tuple:
            Backpack.append(i)
          return Backpack
        
        self.Backpack = pack(Inventory)

#  for NPC
class NPC:
    def __init__(self, Name, Creature, Profession, Value_Self, Value_Others, Value_Society, Aggressive, Suave, Diplomatic, Sincere, Core_Desires_1, Core_Desires_2, Core_Desires_3, Secrets_1, Secrets_2, Secrets_3, Fears_1, Fears_2, Fears_3, Family, Friends, Romantic, Work, Nemesis, Factions, Possesions_1, Possesions_2, Possesions_3, Abilities_1, Abilities_2, Abilities_3):
        self.Name = Name
        self.Creature = Creature
        self.Profession = Profession
        self.Value_Self = Value_Self
        self.Value_Others = Value_Others
        self.Value_Society = Value_Society
        self.Aggressive = Aggressive
        self.Suave = Suave
        self.Diplomatic = Diplomatic
        self.Sincere = Sincere
        self.Core_Desires_1 = Core_Desires_1
        self.Core_Desires_2 = Core_Desires_2
        self.Core_Desires_3 = Core_Desires_3
        self.Secrets_1 = Secrets_1
        self.Secrets_2 = Secrets_2
        self.Secrets_3 = Secrets_3
        self.Fears_1 = Fears_1
        self.Fears_2 = Fears_2
        self.Fears_3 = Fears_3
        self.Family = Family
        self.Friends = Friends
        self.Romantic = Romantic
        self.Work = Work
        self.Nemesis = Nemesis
        self.Factions = Factions
        self.Possesions_1 = Possesions_1
        self.Possesions_2 = Possesions_2
        self.Possesions_3 = Possesions_3
        self.Abilities_1 = Abilities_1
        self.Abilities_2 = Abilities_2
        self.Abilities_3 = Abilities_3

#creatures
class Creature:
    def __init__(self, Name, Size, Shape, Weight, Anatomy, Material, Description, Attacks, Main_Hand, Off_Hand, Utility, Armor, Combat_Special_Moves, Prime, Wounded, Bloodied, Immunities, Weaknesses, Vitals_1, Vitals_2, Vitals_3, Reactions, Combat_Role, Tactics_1, Tactics_2, Tactics_3, Value, Needs, Mission, Role_Playing_Special_Moves, STR, DEX, CON, INT, WIS, CHA, Muscle, Wrestle, Brawl, Jump, Coordination, Finesse, Sleight, Stealth, Endurance, Concentration, Vitality, Academic, Arcana, Culture, Search, Nature, Insight, Interaction, Medicine, Perception, Survival, Aggressive, Suave, Diplomatic, Sincere, Adventuring_Special_Moves, Adventuring_Difficulty, Role_Playing_Difficulty, Combat_Difficulty, *Inventory):
        
        
        self.visibility = {
            "Name":False,
            "Size":False,
            "Shape":False,
            "Weight":False,
            "Anatomy":False,
            "Material":False,
            "Description":False,
            "Attacks":False,
            "Equipment":False,
            "Armor":False,
            "Combat_Special_Moves":False,
            "Max_HP":False,
            "Prime_HP":False,
            "Wounded_HP":False,
            "Bloodied_HP":False,
            "Immunities":False,
            "Weaknesses":False,
            "Vitals_1":False,
            "Vitals_2":False,
            "Vitals_3":False,
            "Reactions":False,
            "Combat_Role":False,
            "Tactics_1":False,
            "Tactics_2":False,
            "Tactics_3":False,
            "Statuses":False,
            "Values":False,
            "Needs":False,
            "Mission":False,
            "Role_Playing_Special_Moves":False,
            "Stats":False,
            "Skills":False,
            "Speed":False,
            "Adventuring_Special_Moves":False,
            "Combat_Difficulty":False,
            "Role_Playing_Difficulty":False,
            "Adventuring_Difficulty":False            
        }


        self.Hostile = False

        self.Name = Name
        self.Size = Size
        self.Shape = Shape
        self.Weight = Weight
        self.Anatomy = Anatomy
        self.Material = Material
        self.Description = Description

        #Combat = #Combat


        self.Attacks = Attacks
        self.Armor = Armor
        self.Combat_Special_Moves = Combat_Special_Moves
        self.Prime = Prime
        self.Wounded = Wounded
        self.Bloodied = Bloodied
        self.Immunities = Immunities
        self.Weaknesses = Weaknesses
        self.Vitals_1 = Vitals_1
        self.Vitals_2 = Vitals_2
        self.Vitals_3 = Vitals_3
        self.Reactions = Reactions
        self.Combat_Role = Combat_Role
        self.Tactics = {
            1:Tactics_1,
            2:Tactics_2,
            3:Tactics_3
        }


        self.Max_HP = Prime + Wounded + Bloodied
        #base ap... should never change in battle
        self.Base_AP = 6
        self.Base_RP = 6
        self.Base_MP = 6

        #Max ap... is what is restored at the top of each turn and can change through out the battle
        self.Max_AP = 6
        self.Max_RP = 6
        self.Max_MP = 6
        
        self.Stamina = "Prime"
        
        self.HP = {
            "Total":Prime + Wounded + Bloodied,
            "Prime":Prime, 
            "Wounded":Wounded, 
            "Bloodied":Bloodied
        }
        
        self.AP = 6
        self.RP = 6
        self.MP = 6

        #we need to add dictionaries for every phase of the encounter both pre and post
        self.Open_Phase = {}
        self.Post_Open_Phase = {}
        self.Pre_Action = {}
        self.Post_Action = {}
        self.Pre_Reaction = {}
        self.Post_Reaction = {}
        self.Pre_Roll = {}
        self.Post_Roll = {}

        
        self.temp_bonus = 0
        self.misc_bonus = 0
        self.crit_threshold = 20
        self.crit_fail_threshold = 1

        self.Statuses = {
            "Bleeding":0,
            "Blinded":0,
            "Crippled":0,
            "Deafened":0,
            "Fatigued":0,
            "Captivated":0,
            "Confused":0,
            "Frightened":0,
            "Stunned":0,
            "Unconscious":0,
            "Burning":0,
            "Impaled":0,
            "Momentum":0,
            "Prone":0,
            "Restrained":0,
            "Suffocating":0,
            "Surprised":0
        }

        self.Captivated_Source = {}
        self.Frightened_Source = {}

        #positions

        self.Location = {
            "x":0,
            "y":0,
            "z":0 
        }

        self.Positions = {
            "Cover":0,
            "Flanked":0,
            "Hidden":0,
            "High Ground":0,
            "Unbalanced":0
        }

        self.Direction = 0

        #Charisma = #Charisma
        self.Value = Value
        self.Needs = Needs
        self.Mission = Mission
        self.Role_Playing_Special_Moves = Role_Playing_Special_Moves

                # STATS and SKILLS

        self.Attributes_Base = {
            "STR": STR,
            "DEX": DEX,
            "CON": CON,
            "INT": INT,
            "WIS": WIS,
            "CHA": CHA
        }

        self.Attributes = {
            "STR": STR,
            "DEX": DEX,
            "CON": CON,
            "INT": INT,
            "WIS": WIS,
            "CHA": CHA
        }


        self.Skills_Base = {
            "Muscle": Muscle,
            "Wrestle": Wrestle,
            "Brawl": Brawl,
            "Jump": Jump,
            "Coordination": Coordination,
            "Finesse": Finesse,
            "Sleight": Sleight,
            "Stealth": Stealth,
            "Endurance": Endurance,
            "Concentration": Concentration,
            "Vitality": Vitality,
            "Academic": Academic,
            "Arcana": Arcana,
            "Culture":  Culture,
            "Search": Search,
            "Nature": Nature,
            "Insight": Insight,
            "Interaction": Interaction,
            "Medicine": Medicine,
            "Perception": Perception,
            "Survival": Survival,
            "Aggressive": Aggressive,
            "Suave": Suave,
            "Diplomatic": Diplomatic,
            "Sincere": Sincere
        }

        self.Skills = {
            "Muscle": Muscle,
            "Wrestle": Wrestle,
            "Brawl": Brawl,
            "Jump": Jump,
            "Coordination": Coordination,
            "Finesse": Finesse,
            "Sleight": Sleight,
            "Stealth": Stealth,
            "Endurance": Endurance,
            "Concentration": Concentration,
            "Vitality": Vitality,
            "Academic": Academic,
            "Arcana": Arcana,
            "Culture":  Culture,
            "Search": Search,
            "Nature": Nature,
            "Insight": Insight,
            "Interaction": Interaction,
            "Medicine": Medicine,
            "Perception": Perception,
            "Survival": Survival,
            "Aggressive": Aggressive,
            "Suave": Suave,
            "Diplomatic": Diplomatic,
            "Sincere": Sincere
        }


        self.Equipment = {
            "Main Hand":Main_Hand,
            "Off Hand":Off_Hand,
            "Utility":Utility,
            "Armor":armors_dict[Armor]
        }

        self.Attack_Options = {}

        self.Inventory = Inventory

        def pack(Inventory):
          inventory_tuple = Inventory
          Backpack = []
          for i in inventory_tuple:
            Backpack.append(i)
          return Backpack
        
        self.Backpack = pack(Inventory)
       
        self.Adventuring_Special_Moves = Adventuring_Special_Moves



        self.Combat_Difficulty = Combat_Difficulty
        self.Role_Playing_Difficulty = Role_Playing_Difficulty
        self.Adventuring_Difficulty = Adventuring_Difficulty

"""# Dictionaries"""

#actions
actions_dict = {
    "Name": {
            "Type": "Type",
            "Stat": "Stat",
            "Skill": "Skill",
            "Speed": "Speed",
            "Range": "Range",
            "Description": "Description",
            "Dice_Roll": "Dice_Roll",
            "Action_Type": "Action_Type",
            "Reaction": "Reaction",
            "Payload": "print('It is the name action')"
        },
    "Move": {
        "Type": "Movement",
        "Description": "You know... just like move to where you aren't. Pretty much 1 MP per yard.",
        "Payload": '''
move(source)
        '''
        },
    "Weapon Attack":{
            "Type": "Action",
            "Stat": "STR",
            "Skill": "Muscle",
            "Speed": "~",
            "Range": "~",
            "Description": "\u2022Standard attacks vary by weapon and spell. See your attacks for information.\n\u2022You can choose to replace your Muscle mod with a -2 Finesse mod\n\u2022If the weapon has a Balance tag, you can ignore the -2 penalty to your Finesse mod",
            "Dice_Roll": "d20",
            "Action_Type": "Attack",
            "Reaction": "Standard_Reactions",
            "Payload": '''
if source.Attack_Options["Base"] == "Damage":
      damage(target,amount)
    else:
      status(target,source.Attack_Options["Base"],amount)
    for k,v in source.Attack_Options["Technique"]:
      if k != "Distance" or "Pin Point":
        print("You used: " + k)
        exec(techniques_dict[k][v]["Payload"])
      else:
        print("You used: " + k)
            '''
        },
    "Disarm":{
            "Type": "Action",
            "Stat": "STR",
            "Skill": "Muscle",
            "Speed": "2",
            "Range": "1",
            "Description": "\u2022Grab an object held by a target and attempt to pull it away. Make a Disarm contest against the target\u2019s +8 Muscle Check.  On a success, the target is disarmed of the item. \n\u2022Attempting to Disarm a weapon gives the target an opportunity attack against you on a fail.\n\u2022Each Debuff status affecting the target\u2019s arm gives them an additional -3 toward the check. ",
            "Dice_Roll": "d20",
            "Action_Type": "Contest",
            "Reaction": "Muscle",
            "Payload": '''
target_equipment = target.Equipment
print(target_name + " has the following equipped")
for item in target_equipment:
  print(item + " holds: " + str(target_equipment[item]))
weapon_select = input("What hand would you want to select?")
print("You forcibly remove " + target_name + "'s " + target_equipment[weapon_select] + " from their " + weapon_select + " and it falls to the ground")
target_equipment[weapon_select] = None
            
            '''
        },
    "Throw":{
            "Type": "Action",
            "Stat": "STR",
            "Skill": "Muscle",
            "Speed": "2",
            "Range": "Skill check/5 Force Units",
            "Description": "\u2022Make a Throw check on a held object against a target within range. On a hit, the target takes 1 damage or status according to the GM's discretion. \n\u2022You can choose to replace your Muscle mod with a -2 Finesse mod\n\u2022If the object is Weight and < Size 1 you can ignore the -2 penalty to your Finesse mod",
            "Dice_Roll": "d20",
            "Action_Type": "Special",
            "Reaction": "Standard_Reactions",
            "Payload": '''
# item = input("What are you throwing?")
# purpose = input("Are you trying to: Attack, Pass, or Hurl)
# if purpose == "Attack":
#   target = input("Who are you trying to attack?")
#   special_attack(source,target,)
print('Throw isnt done yet. GM, go ahead and fill in the blanks')
            '''
        },
    "Choke":{
            "Type": "Action",
            "Stat": "STR",
            "Skill": "Wrestle",
            "Speed": "4",
            "Range": "1",
            "Description": "\u2022Make a Choke check contested against the target\u2019s Muscle check. On a success the target takes a stage of Suffocating",
            "Dice_Roll": "d20",
            "Action_Type": "Contest",
            "Reaction": "Wrestle",
            "Payload": '''
status(target,'Suffocating',1)
print(target_name + "'s suffocating stage is now: " + str(target.Statuses["Suffocating"]))
            '''
        },
    "Grapple":{
            "Type": "Action",
            "Stat": "STR",
            "Skill": "Wrestle",
            "Speed": "4",
            "Range": "1",
            "Description": "\u2022Make a Grapple check contested against the target\u2019s Muscle check. On a success the target takes a stage of Restrained",
            "Dice_Roll": "d20",
            "Action_Type": "Contest",
            "Reaction": "Wrestle",
            "Payload": '''
status(target,'Restrained',1)
print(target_name + "'s restrained stage is now: " + str(target.Statuses["Restrained"]))
            '''
        },
    "Strike":{
            "Type": "Action",
            "Stat": "STR",
            "Skill": "Brawl",
            "Speed": 1,
            "Range": "1",
            "Description": "\u2022Make a Strike check against a target\u2019s choice of reaction. On a hit, the target takes a stage of Stunned for every 2 hits they have taken during your turn (Attack, special move, or another Strike).",
            "Dice_Roll": "d20",
            "Action_Type": "Attack",
            "Reaction": "Standard_Reactions",
            "Payload": '''
status(target,'Stunned',1)
print(target_name + "'s stunned stage is now: " + str(target.Statuses["Stunned"]))
            '''
        },
    "Shove":{
            "Type": "Action",
            "Stat": "STR",
            "Skill": "Brawl",
            "Speed": "2",
            "Range": "1",
            "Description": "\u2022Make a Shove check contested against the target\u2019s Muscle check. On a success the target takes a stage of Prone",
            "Dice_Roll": "d20",
            "Action_Type": "Contest",
            "Reaction": "Muscle",
            "Payload": '''
status(target,'Prone',1)
print(target_name + "'s prone stage is now: " + str(target.Statuses["Prone"]))
            '''
        },
    "Tackle":{
            "Type": "Action",
            "Stat": "STR",
            "Skill": "Brawl",
            "Speed": "4",
            "Range": "1",
            "Description": "\u2022Make a Tackle check contested against the target\u2019s Muscle check. On a success the target takes a stage of Prone and Grappled. You also take a stage of Prone",
            "Dice_Roll": "d20",
            "Action_Type": "Contest",
            "Reaction": "Muscle",
            "Payload": "print('Tackle isnt done yet. GM, go ahead and fill in the blanks')"
        },
    "Leap":{
            "Type": "Movement",
            "Stat": "STR",
            "Skill": "Jump",
            "Speed": "1",
            "Range": "Jump",
            "Description": "\u2022Declare a distance you want to Leap. Make a Leap check and add your Momentum stages if applicable. \n\u2022Your horizontal range = (Leap check/5) + Momentum Stage \n\u2022Your vertical range =  (Leap check/10) + Momentum Stage\n\u2022If the declared distance is less than the range, you must succeed in a Coordination Check or take a stage of Prone \n\u2022DC = Range * 5\n\u2022You can choose to replace your Jump mod with a -2 Coordination mod",
            "Dice_Roll": "d20",
            "Action_Type": "Range",
            "Reaction": "",
            "Payload": '''


direction = input("Are you leaping horizontal or vertical?")
if direction == 'horizontal':
  amount = result // 5
  target.MP += result // 5
  print("Your horizontal range is : " + str(amount))

else:
  amount = result // 10
  target.MP += 10
  print("Your vertical range is : " + str(amount))

move(source)
            '''
        },
    "Lunge":{
            "Type": "Movement",
            "Stat": "STR",
            "Skill": "Jump",
            "Speed": "1",
            "Range": "1",
            "Description": "\u2022Make a Lunge check to gain stages of Momentum.\n\u2022Momentum stage = Lunge check / 10 ",
            "Dice_Roll": "d20",
            "Action_Type": "Range",
            "Reaction": "",
            "Payload": '''
amount = result // 10
status(target,'Momentum',amount)
print(target_name + "'s momentum stage is now: " + str(target.Statuses["Momentum"]))
            
            '''
        },
    "Climb":{
            "Type": "Movement",
            "Stat": "STR",
            "Skill": "Jump",
            "Speed": "1",
            "Range": "1",
            "Description": "\u2022Make a Climb check to scale up a surface or creature. \n\u2022DC = 5 + (2 * Total climbing range)\n\u2022On a fail, you fall from your height and suffer any applicable effects.",
            "Dice_Roll": "d20",
            "Action_Type": "Range",
            "Reaction": "",
            "Payload": "print('Climb isnt done yet. GM, go ahead and fill in the blanks')"
        },
    "Dive":{
            "Type": "Reaction",
            "Stat": "DEX",
            "Skill": "Coordination",
            "Speed": "2",
            "Range": "Jump",
            "Description": "\u2022Trigger - An Attack is declared against you or you are in the Area of Effect of an Attack or Special Move.\n*Dive automatically fails if Attacks or Special Moves targeting you fill the Area of Effect you are in and you are not within Jumping range of the border of that Attack\u2019s Area of Effect IE: Earthquake\nEffect:\n\u2022Move up to the Range away to gain a +10 on a Dodge Check but land Prone \n\u2022Prone stage = 0 to 8 Stage 3; 9 to 14 stage 2; 15+ Stage 1",
            "Dice_Roll": "d6",
            "Action_Type": "Reaction",
            "Reaction": "",
            "Payload": "print('Dive isnt done yet. GM, go ahead and fill in the blanks')"
        },
    "Dodge":{
            "Type": "Reaction",
            "Stat": "DEX",
            "Skill": "Coordination",
            "Speed": "1",
            "Range": "0",
            "Description": "\u2022Trigger - An Attack is declared against you or you are in the Area of Effect of an Attack or Special Move.\n*Dodge automatically fails if Attacks or Special Moves targeting you fill the Area of Effect you are in and you are not on the border of that Attack\u2019s Area of Effect IE: Earthquake\nEffect:\n\u2022Roll 1d6 and add your Dodge bonus (base + armor) to contest the Attack or evade the effect. On success, you take no damage.",
            "Dice_Roll": "d6",
            "Action_Type": "Reaction",
            "Reaction": "",
            "Payload": ""
        },
    "Parry":{
            "Type": "Reaction",
            "Stat": "DEX",
            "Skill": "Finesse",
            "Speed": "2",
            "Range": "1",
            "Description": "\u2022Trigger - You are selected for the target of a physical or weapon attack\nEffect:\n\u2022Meet an enemies attack with your own. Make a melee Attack roll contest against an incoming physical Attack. The winner of the contest deals damage to the loser if within range. If outside range, the loser\u2019s attack counted as miss\n\u2022You can choose to replace your Finesse mod with a -2 Muscle mod",
            "Dice_Roll": "d20",
            "Action_Type": "Reaction",
            "Reaction": "",
            "Payload": "print('Parry isnt done yet. GM, go ahead and fill in the blanks')"
        },
    "Riposte":{
            "Type": "Reaction",
            "Stat": "DEX",
            "Skill": "Finesse",
            "Speed": "2",
            "Range": "1",
            "Description": "\u2022Trigger - After a successful Parry \nEffect:\n\u2022Counter attack an enemy. Make a Riposte check against the opponents Parry. On a success, the target takes the effect of an Attack action\n\u2022You can choose to replace your Finesse mod with a -2 Muscle mod",
            "Dice_Roll": "d20",
            "Action_Type": "Reaction",
            "Reaction": "",
            "Payload": "print('Riposte isnt done yet. GM, go ahead and fill in the blanks')"
        },
    "Feint":{
            "Type": "Action",
            "Stat": "DEX",
            "Skill": "Sleight",
            "Speed": "2",
            "Range": "Weapon",
            "Description": "\u2022Roll a Feint contest against a target\u2019s Insight check. On a success you deceive a target of your intended attack, and they must roll their intended reaction to the attack. The target cannot use the same reaction against your next attack ",
            "Dice_Roll": "d20",
            "Action_Type": "Contest",
            "Reaction": "Insight",
            "Payload": "print('Feint isnt done yet. GM, go ahead and fill in the blanks')"
        },
    "Steal":{
            "Type": "Action",
            "Stat": "DEX",
            "Skill": "Sleight of Hand",
            "Speed": "2",
            "Range": "1",
            "Description": "\u2022An attempt to take an equipped weapon or item from an equipment slot of the Target (not from a hand). Make a Steal contest against the target\u2019s +8 Perception check. On a success, you take the item, on a fail the target is given a free opportunity attack against you\n\u2022Each stage of the Concealed status you have against the target gives you an additional +3 toward the Steal check",
            "Dice_Roll": "d20",
            "Action_Type": "Contest",
            "Reaction": "Perception",
            "Payload": '''
source = str(source)
source_name = eval(source).Name
print(target_name + " has the following on them:")
for i in eval(target_name).Backpack:
  print(i)
purpose = input("Which would you like to take?")

eval(target_name + ".Backpack.remove(purpose)")
eval(source_name + ".Backpack.append(purpose)")
print(source_name + ", you now have the " + purpose + " in your backpack")
            '''
        },
    "Trip":{
            "Type": "Reaction",
            "Stat": "DEX",
            "Skill": "Sleight of Hand",
            "Speed": "2",
            "Range": "1",
            "Description": "\u2022Trigger - A target moves through a space adjacent to you\nEffect:\n\u2022Make a Trip check contested against a target\u2019s +3 Coordination check. On a success the target takes a stage of Prone \n\u2022Prone stage = Contest difference/5 rounded down\n\u2022Each Momentum stage -3 from the target\u2019s Coordination check",
            "Dice_Roll": "d20",
            "Action_Type": "Reaction",
            "Reaction": "",
            "Payload": '''
status(source,'Prone',1)
print(source_name + "'s prone stage is now: " + str(source.Statuses["Prone"]))
            '''
        },
    "Hide":{
            "Type": "Movement",
            "Stat": "DEX",
            "Skill": "Stealth",
            "Speed": "2",
            "Range": "0",
            "Description": "\u2022Attempt to hide away from view. Make a Hide check. DC determined by the GM. On a success, you gain 1 stage of Hidden",
            "Dice_Roll": "d20",
            "Action_Type": "DC",
            "Reaction": "",
            "Payload": '''
eval(target_name).Positions['Hidden'] += 1
print(target_name + "'s hidden stage is now: " + str(eval(target_name).Positions["Hidden"]))
            '''
        },
    "Block":{
            "Type": "Reaction",
            "Stat": "CON",
            "Skill": "Endurance",
            "Speed": "1",
            "Range": "0",
            "Description": "\u2022Trigger - An Attack or special move is declared against you or you are in the Area of Effect of an Attack or special move.\nEffect:\n\u2022Roll 1d6 and add your Block bonus (base + armor) to contest the Attack or evade the effect. On success, you take no damage",
            "Dice_Roll": "d6",
            "Action_Type": "Reaction",
            "Reaction": "",
            "Payload": ""
        },
    "Brace":{
            "Type": "Action",
            "Stat": "CON",
            "Skill": "Endurance",
            "Speed": "2",
            "Range": "0",
            "Description": "\u2022Roll a Brace check to give yourself an additional d6's to use on reactions until the start of your next turn. \n\u2022Number of d6's = the Brace check /5 (rounded down)",
            "Dice_Roll": "d20",
            "Action_Type": "Range",
            "Reaction": "",
            "Payload": '''
target.RP += result // 5
print(target_name + "'s RP is now: " + str(target.RP))
            '''
        },
    "Charge Power":{
        "Type": "Action",
        "Stat": "CON",
        "Skill": "Concentration",
        "Speed": "2",
        "Range": "0",
        "Description": "\u2022Roll a Charge Power check to gain momentum towards your next Power Rank \n\u2022DC = 10 + Power Rank",
        "Dice_Roll": "d20",
        "Action_Type": "Range",
        "Reaction": "",
        "Payload": '''
eval(target_name).Power_Rank += 1
print(target_name + "'s power tier stage is now: " + str(target.Power_Rank))
            '''
        },
    "Concentrate":{
            "Type": "Action",
            "Stat": "CON",
            "Skill": "Concentration",
            "Speed": "2",
            "Range": "0",
            "Description": "\u2022Maintain Concentration on the spell or effect. DC = 8 + power rank of spell + number of turns concentrated.",
            "Dice_Roll": "d20",
            "Action_Type": "DC",
            "Reaction": "",
            "Payload": '''

purpose = input("What mental status do you want to heal?")
current_stage = target.Statuses[purpose]
status(target,purpose,-current_stage)
print(target_name + ", your " + purpose + " is now: " + str(target).Statuses[purpose]))
            '''
        },
    "Focus":{
            "Type": "Action",
            "Stat": "CON`",
            "Skill": "Concentration",
            "Speed": "2",
            "Range": "0",
            "Description": "\u2022Focus can be applied before any action to raise the minimum roll value. \n\u2022Roll a Focus check and divide it in half to make a focus value. On your following action, any dice roll below this focus value will be treated as the focus value instead of the dice value (except for Crit fails).",
            "Dice_Roll": "d20",
            "Action_Type": "Range",
            "Reaction": "",
            "Payload": '''
print('GM, go ahead and tell raise the lowest dice roll value to: ' + str(result // 2))
'''
        },
    "Recover":{
            "Type": "Action",
            "Stat": "CON",
            "Skill": "Vitality",
            "Speed": "0",
            "Range": "2",
            "Description": "\u2022Roll a Recover Check to regain a damaged health block. DC = 8 + 1 per Debuff status currently affecting you AND Missing Health Block",
            "Dice_Roll": "d20",
            "Action_Type": "Range",
            "Reaction": "",
            "Payload": '''
target_stamina = eval(target_name).Stamina
target_health = eval(target_name + "." + target_stamina)
print("You currenlty have : " + str(target_health) + " HP")
target_health += result // 10

print("Your " + target_stamina + " stamina now has: " + str(target_health) + " HP")
            '''
        },
    "Enemy History":{
            "Type": "Action",
            "Stat": "INT",
            "Skill": "Academic",
            "Speed": "1",
            "Range": "24",
            "Description": "\u2022Tap knowledge of any historical record or mentions of this specific group. DC is determined by the GM",
            "Dice_Roll": "d20",
            "Action_Type": "DC",
            "Reaction": "",
            "Payload": "print('GM, go ahead and tell them what know about the NPC')"
        },
    "Arcana":{
            "Type": "Action",
            "Stat": "INT",
            "Skill": "Arcane",
            "Speed": "1",
            "Range": "24",
            "Description": "\u2022Tap knowledge of what magic is being used and what effects it has. DC is determined by the GM",
            "Dice_Roll": "d20",
            "Action_Type": "DC",
            "Reaction": "",
            "Payload": "print('GM, go ahead and tell them what they know about the magic')"
        },
    "Tactics":{
            "Type": "Action",
            "Stat": "INT",
            "Skill": "Culture",
            "Speed": "1",
            "Range": "24",
            "Description": "\u2022Roll a Tactics check to tap knowledge of any specific tactics used by the enemy's Stat Block. DC is determined by the GM",
            "Dice_Roll": "d20",
            "Action_Type": "DC",
            "Reaction": "",
            "Payload": '''
if target.visibility["Tactics_1"] and target.visibility["Tactics_2"] and target.visibility["Tactics_3"] == False :
  target.visibility["Tactics_1"] = True
  print(target_name + "'s Tactics 1 is: " + target.Tactics[1])
elif target.visibility["Tactics_3"] and target.visibility["Tactics_2"] == False:
  target.visibility["Tactics_2"] = True
  print(target_name + "'s Tactics 1 is: " + target.Tactics[1])
  print(target_name + "'s Tactics 2 is: " + target.Tactics[2])
elif target.visibility["Tactics_3"] == False:
  target.visibility["Tactics_3"] = True
  print(target_name + "'s Tactics 1 is: " + target.Tactics[1])
  print(target_name + "'s Tactics 2 is: " + target.Tactics[2])
  print(target_name + "'s Tactics 3 is: " + target.Tactics[3])
  '''
        },
    "Search":{
            "Type": "Action",
            "Stat": "INT",
            "Skill": "Investigation",
            "Speed": "2",
            "Range": "1",
            "Description": "",
            "Dice_Roll": "d20",
            "Action_Type": "DC",
            "Reaction": "",
            "Payload": "print('GM, go ahead and tell them what they found')"
        },
    "Battlefield":{
            "Type": "Action",
            "Stat": "INT",
            "Skill": "Nature",
            "Speed": "1",
            "Range": "24",
            "Description": "\u2022Tap knowledge of any advantages or weaknesses presented on the battlefield. DC is determined by the GM",
            "Dice_Roll": "d20",
            "Action_Type": "DC",
            "Reaction": "",
            "Payload": "print('GM, go ahead and tell the player the positions on the field')"
        },
    "Enemy Status":{
            "Type": "Action",
            "Stat": "WIS",
            "Skill": "Insight",
            "Speed": "1",
            "Range": "24",
            "Description": "\u2022Roll an Enemy Status contested by a target's Sleight to read an enemies' health and difficulty.",
            "Dice_Roll": "d20",
            "Action_Type": "Contest",
            "Reaction": "Sleight",
            "Payload": '''
target.visibility["Max_HP"] = True
print(target_name + "'s max HP is: " + str(target.Max_HP))
            '''
        },
    "Coordinated Attack":{
            "Type": "Action",
            "Stat": "WIS",
            "Skill": "Interaction",
            "Speed": "6",
            "Range": "12",
            "Description": "\u2022Roll a Coordinated Attack check to invite an ally within range to perform actions (with you) in succession. \n\u2022You and your ally spend their 12 AP for the round to share a single turn and with a total combined AP for both of you equal to your Coordinated Attack check\n\u2022You are limited to movement and one action each.",
            "Dice_Roll": "d20",
            "Action_Type": "Attack",
            "Reaction": "",
            "Payload": "print('Coordinated Attack isnt done yet. GM, go ahead and fill in the blanks')"
        },
    "Improvise":{
            "Type": "Action",
            "Stat": "WIS",
            "Skill": "Interaction",
            "Speed": "1",
            "Range": "-",
            "Description": "\u2022Find a branch for a quick weapon, kick dirt to put out a fire, or use your ingenuity to solve a quick problem. DC set by GM.",
            "Dice_Roll": "d20",
            "Action_Type": "DC",
            "Reaction": "",
            "Payload": "print('Improvise isnt done yet. GM, go ahead and fill in the blanks')"
        },
        #this one needs to fix the last else now that there is a set function for reducing and increasing statuses
    "Bandage":{
            "Type": "Action",
            "Stat": "WIS",
            "Skill": "Medicine",
            "Speed": "2",
            "Range": "1",
            "Description": "\u2022Aid an ally by Healing a Health Block or 1 status (if applicable). DC determined by Status or GM",
            "Dice_Roll": "d20",
            "Action_Type": "DC",
            "Reaction": "",
            "Payload": '''
target_name = input("Who would you like to bandage?")
target_stamina = eval(target_name).Stamina
target_health = eval(target_name + "." + target_stamina)

print(target_name + " is currently in their " + target_stamina + " stamina which currenlty has : " + str(target_health) + " HP")

purpose = input("Would you like to give them health or type the status you'd like to Bandage.")
if purpose == "health":
  target_health += 1
  print(target_name + "'s " + target_stamina + " stamina now has: " + str(target_health) + " HP")
else:
  status = eval(purpose)
  eval(target_name).status = 1
  print(target_name + "'s " + purpose + " is now at stage: " + str(eval(target_name).status))
            '''
        },
    "Aim":{
            "Type": "Action",
            "Stat": "WIS",
            "Skill": "Perception",
            "Speed": "2",
            "Range": "Attack Range",
            "Description": "\u2022Roll an Aim check to improve the accuracy of your next attack (action or special move) against a single target you can see. Add your Aim Check total divided by 4 to your following attack roll. ",
            "Dice_Roll": "d20",
            "Action_Type": "Range",
            "Reaction": "",
            "Payload": '''
target.temp_bonus += result // 4
print("Your following attack with have a bonus of: " + str(target.temp_bonus))
            '''
        },
    "Find Vitals":{
            "Type": "Action",
            "Stat": "WIS",
            "Skill": "Survival",
            "Speed": "2",
            "Range": "24",
            "Description": "\u2022Roll a Find Vitals contested against a target's Insight to determine an enemies Vital points. On a success, the vital stage you learn is equal to your Find Vitals check divided by 10",
            "Dice_Roll": "d20",
            "Action_Type": "Contest",
            "Reaction": "Insight",
            "Payload": '''
if target.visibility["Vitals_1"] and target.visibility["Vitals_2"] and target.visibility["Vitals_3"] == False :
  target.visibility["Vitals_1"] = True
  print(target_name + "'s vital 1 is: " + target.Vitals_1)
elif target.visibility["Vitals_3"] and target.visibility["Vitals_2"] == False:
  target.visibility["Vitals_2"] = True
  print(target_name + "'s vital 1 is: " + target.Vitals_1)
  print(target_name + "'s vital 2 is: " + target.Vitals_2)
elif target.visibility["Vitals_3"] == False:
  target.visibility["Vitals_3"] = True
  print(target_name + "'s vital 1 is: " + target.Vitals_1)
  print(target_name + "'s vital 2 is: " + target.Vitals_2)
  print(target_name + "'s vital 3 is: " + target.Vitals_3)
            '''
        },
    "Taunt":{
            "Type": "Action",
            "Stat": "CHA",
            "Skill": "Aggressive",
            "Speed": "2",
            "Range": "24",
            "Description": "\u2022Roll a Taunt check against a target's Concentration to inflict the Captivated or Frightened status to a target.",
            "Dice_Roll": "d20",
            "Action_Type": "Contest",
            "Reaction": "Concentration",
            "Payload": '''
preference = input("Are you trying to frighten or captivate the target?")
if preference == "frighten":
  status(target,'Frightened',1)
  print(target_name + "'s Frightened status is now: " + str(target.Statuses["Frightened"]))
else:
  status(target,'Captivated',1)
  print(target_name + "'s Captivated status is now: " + str(target.Statuses["Captivated"]))
            '''
        },
    "Distract":{
            "Type": "Action",
            "Stat": "CHA",
            "Skill": "Suave",
            "Speed": "2",
            "Range": "24",
            "Description": "\u2022Roll a Distract check against a target's Concentration to give a target a level of Flanked.",
            "Dice_Roll": "d20",
            "Action_Type": "Contest",
            "Reaction": "Concentration",
            "Payload": '''
target.Positions['Flanked'] += 1
print(target_name + "'s flanked stage is now: " + str(target.Positions["Flanked"]))
            '''
        },
    "Pacify":{
            "Type": "Action",
            "Stat": "CHA",
            "Skill": "Diplomatic",
            "Speed": "2",
            "Range": "24",
            "Description": "\u2022Roll a Pacify check against a target's Diplomatic check to try and convince a them to withdraw from combat. On a success, initiative is paused.",
            "Dice_Roll": "d20",
            "Action_Type": "Contest",
            "Reaction": "Diplomatic",
            "Payload": '''
target.Hostility = False
print(target_name + "'s is no longer hostile.")
            '''
        },
    "Encourage":{
            "Type": "Action",
            "Stat": "CHA",
            "Skill": "Sincere",
            "Speed": "2",
            "Range": "24",
            "Description": "\u2022Roll an Encourage check against a target to give an ally one stage of the Bolstered status. DC determined by GM",
            "Dice_Roll": "d20",
            "Action_Type": "DC",
            "Reaction": "",
            "Payload": '''
target_name = input("Who do you wish to encourage?")
eval(target_name).Statuses[Captivated] = 0
eval(target_name).Statuses[Confused] = 0
eval(target_name).Statuses[Frightened] = 0
eval(target_name).Statuses[Stunned] = 0
print(target_name + "'s mental statuses are cleared")
            '''
        }
  }

#armors

armors_dict = {
    "armor_name": {
        "Name": "String",
        "Type": "string(armor types)",
        "Defend": "int",
        "Block_Bonus": "float(.5, 1, or 0)",
        "Dodge_Base": "int",
        "Dodge_Bonus": "float(.5, 1, or 0)",
        "Mobility": "int",
        "Durability": "int",
        "Features": ["string"],
        "Techniques": "string",
        "Vital1": "string",
        "Vital2": "sting",
        "Vital3": "string"
    },
    "Unarmored": {
        "Name": "Unarmored",
        "Type": "Light",
        "Defend": 6,
        "Block_Bonus": 1,
        "Agility": 10,
        "Dodge_Bonus": 1,
        "Mobility": 6,
        "Durability": 0,
        "Features": [],
        "Techniques": "Unburdened 3",
        "Vital1": "1d6",
        "Vital2": "1d6 + 1/2 Dodge",
        "Vital3": "1d6 + Dodge"
    },
    "Leather Armor": {
        "Name": "Leather Armor",
        "Type": "Light",
        "Defend": 8,
        "Block_Bonus": 0,
        "Agility": 12,
        "Dodge_Bonus": .5,
        "Mobility": 5,
        "Durability": "6",
        "Features": [],
        "Techniques": "Utility 2, Nimble 1",
        "Vital1": "1d6",
        "Vital2": "2d6",
        "Vital3": "2d6 + 1/2 Dodge"
    },
    "Gambeson": {
        "Name": "Gambeson",
        "Type": "Light",
        "Defend": 10,
        "Block_Bonus": 0,
        "Agility": 10,
        "Dodge_Bonus": .5,
        "Mobility": 5,
        "Durability": 6,
        "Features": [],
        "Techniques": "Nimble 2",
        "Vital1": "1d6",
        "Vital2": "2d6",
        "Vital3": "2d6 + 1/2 Dodge"
    },
    "Chain Mail": {
        "Name": "Chain Mail",
        "Type": "Medium",
        "Defend": 12,
        "Block_Bonus": .5,
        "Agility": 12,
        "Dodge_Bonus": .5,
        "Mobility": 4,
        "Durability": 8,
        "Features": [],
        "Techniques": "Fortified 2",
        "Vital1": "1d6",
        "Vital2": "2d6",
        "Vital3": "2d6 + 1/2 Dodge or 1/2 Block"
    },
    "Splint Mail": {
        "Name": "Splint Mail",
        "Type": "Medium",
        "Defend": 13,
        "Block_Bonus": .5,
        "Agility": 10,
        "Dodge_Bonus": 0,
        "Mobility": 4,
        "Durability": 8,
        "Features": [],
        "Techniques": "Fortified 2",
        "Vital1": "1d6",
        "Vital2": "2d6 + 1/2 Block",
        "Vital3": "3d6 + 1/2 Block"
    },
    "Breast Plate": {
        "Name": "Breast Plate",
        "Type": "Medium",
        "Defend": 9,
        "Block_Bonus": 0,
        "Agility": 11,
        "Dodge_Bonus": .5,
        "Mobility": 5,
        "Durability": 8,
        "Features": [],
        "Techniques": " Nimble 2",
        "Vital1": "1d6 + 1/2 Dodge",
        "Vital2": "2d6 + 1/2 Block",
        "Vital3": "3d6 + 1/2 Block"
    },
    "Scale Mail": {
        "Name": "Scale Mail",
        "Type": "Heavy",
        "Defend": 13,
        "Block_Bonus": .5,
        "Agility": 8,
        "Dodge_Bonus": 0,
        "Mobility": 4,
        "Durability": 7,
        "Features": [],
        "Techniques": "Fortified 2",
        "Vital1": "1d6 + 1/2 Block",
        "Vital2": "2d6 + 1/2 Block",
        "Vital3": "3d6 + 1/2 Block"
    },
    "Plate Mail": {
        "Name": "Plate Mail",
        "Type": "Heavy",
        "Defend": 14,
        "Block_Bonus": .5,
        "Agility": 7,
        "Dodge_Bonus": 0,
        "Mobility": 3,
        "Durability": 9,
        "Features": [],
        "Techniques": "Fortified 2, Braced 2",
        "Vital1": "1d6 + 1/2 Block",
        "Vital2": "2d6 + 1/2 Block",
        "Vital3": "3d6 + Block"
    },
    "Full Plate": {
        "Name": "Full Plate",
        "Type": "Heavy",
        "Defend": 15,
        "Block_Bonus": 1,
        "Agility": 6,
        "Dodge_Bonus": 0,
        "Mobility": 2,
        "Durability": 10,
        "Features": [],
        "Techniques": "Fortified 2, Braced 2",
        "Vital1": "1d6 + Block",
        "Vital2": "2d6 + Block",
        "Vital3": "3d6 + Block"
    }
    }

# weapons
weapons_dict = {
    "weapon_name":{
        "Name": "String",
        "Type": "string(handed)",
        "Damage_Type": "string(damage types)",
        "Crit_Damage": "int",
        "Range": "int",
        "AP": "int",
        "Features": ["strings(list from weapons key)"],
        "Techniques": "strings(list from weapons key)",
        "Description": "string(long form)"
    },
    "Dagger":{
        "Name": "Dagger",
        "Type": "One Handed",
        "Damage_Type": "Piercing",
        "Crit_Damage": 2,
        "Range": 1,
        "AP": 2,
        "Features":["Dual Wielding","Finesse"],
        "Techniques": "",
        "Description": ""
    },
    "Flail":{
        "Name": "Flail",
        "Type": "One Handed",
        "Damage_Type": "Bludgeoning",
        "Crit_Damage": 2,
        "Range": 2,
        "AP": 4,
        "Features": ["Grappling"],
        "Techniques": {"Impact":1},
        "Description": ""
    },
    "War Hammer":{
        "Name": "War Hammer",
        "Type": "One Handed",
        "Damage_Type": "Bludgeoning",
        "Crit_Damage": 2,
        "Range": 1,
        "AP": 3,
        "Features": [],
        "Techniques": {"Crush":1},
        "Description": ""
    },
    "Hand Axe":{
        "Name": "Hand Axe",
        "Type": "One Handed",
        "Damage_Type": "Slashing",
        "Crit_Damage": 2,
        "Range": 1,
        "AP": 3,
        "Features": ["Dual Wielding"],
        "Techniques": {"Cleave":1},
        "Description": ""
    },
    "Katana":{
        "Name": "Katana",
        "Type": "One Handed",
        "Damage_Type": "Slashing",
        "Crit_Damage": 2,
        "Range": 1,
        "AP": 3,
        "Features": ["Dual Wielding", "Finesse", "Dualing"],
        "Techniques": {"Cleave":1, "Flurry":1, "Rend":1},
        "Description": ""
    },
    "Long Sword":{
        "Name": "Long Sword",
        "Type": "One Handed",
        "Damage_Type": "Slashing",
        "Crit_Damage": 2,
        "Range": 1,
        "AP": 3,
        "Features": ["Versatile","Dueling"],
        "Techniques": {"Rend": 1},
        "Description": ""
    },
    "Mace":{
        "Name": "Mace",
        "Type": "One Handed",
        "Damage_Type": "Bludgeoning",
        "Crit_Damage": 2,
        "Range": 1,
        "AP": 3,
        "Features": [],
        "Techniques": "Crippling 2; Momentum 2; Dueling 1",
        "Description": ""
    },
    "Rapier":{
        "Name": "Rapier",
        "Type": "One Handed",
        "Damage_Type": "Piercing",
        "Crit_Damage": 2,
        "Range": 1,
        "AP": 3,
        "Features": ["Dueling", "Finesse"],
        "Techniques": {"Flurry": 2},
        "Description": ""
    },
    "Short Sword":{
        "Name": "Short Sword",
        "Type": "One Handed",
        "Damage_Type": "Slashing",
        "Crit_Damage": 2,
        "Range": 1,
        "AP": 3,
        "Features": ["Dueling", "Finesse"],
        "Techniques": {"Flurry": 1},
        "Description": ""
    },
    "Whip":{
        "Name": "Whip",
        "Type": "One Handed",
        "Damage_Type": "Slashing",
        "Crit_Damage": 2,
        "Range": 3,
        "AP": 3,
        "Features": ["Grappling"],
        "Techniques": [{"Rend": 1}],
        "Description": ""
    },
    "Maul":{
        "Name": "Maul",
        "Type": "Two Handed",
        "Damage_Type": "Bludgeoning",
        "Crit_Damage": 3,
        "Range": 1,
        "AP": 4,
        "Features": ["Heavy"],
        "Techniques": {"Impact": 2, "Crush": 2},
        "Description": ""
    },
    "Great Sword":{
        "Name": "Great Sword",
        "Type": "Two Handed",
        "Damage_Type": "Slashing",
        "Crit_Damage": 3,
        "Range": 1,
        "AP": 4,
        "Features": ["Heavy", "Versatile"],
        "Techniques": {"Cleave": 2, "Rend": 2},
        "Description": ""
    },
    "Battle Axe":{
        "Name": "Battle Axe",
        "Type": "Two Handed",
        "Damage_Type": "Slashing",
        "Crit_Damage": 3,
        "Range": 1,
        "AP": 4,
        "Features": ["Heavy"],
        "Techniques": {"Cleave": 2, "Rend": 2},
        "Description": ""
    },
    "Spear":{
        "Name": "Spear",
        "Type": "Two Handed",
        "Damage_Type": "Piercing",
        "Crit_Damage": 3,
        "Range": 2,
        "AP": 3,
        "Features": ["Finesse", "Thrown"],
        "Techniques": {"Flurry": 1, "Impact": 2},
        "Description": ""
    },
    "Quarterstaff":{
        "Name": "Quarterstaff",
        "Type": "Two Handed",
        "Damage_Type": "Bludgeoning",
        "Crit_Damage": 2,
        "Range": 2,
        "AP": 3,
        "Features": [],
        "Techniques": {"Flurry": 2},
        "Description": ""
    },
    "Glaive":{
        "Name": "Glaive",
        "Type": "Two Handed",
        "Damage_Type": "Slashing",
        "Crit_Damage": 2,
        "Range": 2,
        "AP": 4,
        "Features": ["Versatile"],
        "Techniques": {"Impact": 1},
        "Description": ""
    },
    "Heavy Crossbow":{
        "Name": "Heavy Crossbow",
        "Type": "Ranged",
        "Damage_Type": "Piercing",
        "Crit_Damage": 3,
        "Range": 15,
        "AP": 1,
        "Features": ["Finesse","Reload"],
        "Techniques": {"Distance": 1, "Pin Point": 2},
        "Description": ""
    },
    "Javelin":{
        "Name": "Javelin",
        "Type": "Ranged",
        "Damage_Type": "Piercing",
        "Crit_Damage": 3,
        "Range": 5,
        "AP": 3,
        "Features": ["Finesse","Thrown"],
        "Techniques": {"Impact": 2},
        "Description": ""
    },
    "Light Crossbow":{
        "Name": "Light Crossbow",
        "Type": "Ranged",
        "Damage_Type": "Piercing",
        "Crit_Damage": 2,
        "Range": 5,
        "AP": 1,
        "Features": ["Finesse, Reload"],
        "Techniques": {"Distance":1,"Pin Point":1},
        "Description": ""
    },
    "Longbow":{
        "Name": "Longbow",
        "Type": "Ranged",
        "Damage_Type": "Piercing",
        "Crit_Damage": 2,
        "Range": 15,
        "AP": 3,
        "Features": ["Finesse"],
        "Techniques": {"Distance": 2},
        "Description": ""
    },
    "Short Bow":{
        "Name": "Short Bow",
        "Type": "Ranged",
        "Damage_Type": "Piercing",
        "Crit_Damage": 2,
        "Range": 5,
        "AP": 3,
        "Features": ["Finesse"],
        "Techniques": {"Distance": 1,"Flurry": 1},
        "Description": ""
    },
    "Throwing Knives":{
        "Name": "Throwing Knives",
        "Type": "Ranged",
        "Damage_Type": "Piercing",
        "Crit_Damage": 3,
        "Range": 5,
        "AP": 2,
        "Features": ["Finesse","Thrown"],
        "Techniques": {"Distance": 1,"Flurry": 1},
        "Description": ""
    }
    }

techniques_dict = {
   "Name":{
      "Info":"String",
      1:{
          "Description":"String",
          "Payload":'''

         '''
      },
      2:{
          "Description":"String",
          "Payload":'''

         '''
      },
      3:{
          "Description":"String",
          "Payload":'''

         '''
      }
    },
    "Cleave":{
      "Info":"String",
      1:{
          "Description":"You can attempt to hit 2 targets. Both will roll reactions against the same attack roll",
          "Payload":'''

target2 = input("What second target do you want to attack")
target2 = make_class(target2)
if distance(source,target2) != 1:
  while distance(source,target2) != 1:
    target2 = input(This target is too far away, please select another target)

reaction2 = input(target2.Name + ", how do you react?")

result = attack(source,"Weapon Attack",target2,reaction)

if result == "Critical":
  damage(target2,weapons_dict[weapon]["Crit_Damage"])
elif result == "Fail":
  print("Sorry you Suck")
elif result == 'Critical Fail':
  print("You really suck bad")
else:
  exec(actions_dict[action]["Payload"])


         '''
      },
      2:{
          "Description":"You can attempt to hit up to 3 targets. All targets will roll reactions against the same attack roll.",
          "Payload":'''
targets = []

while len(targets) < 2:
  confirmation = input("Do you want to attack another target?")
  if confirmation == 'yes':
    new_target = input("Who would you like to target?)
    
    if distance(source,new_target) != 1:
      while distance(source,new_target) != 1:
        new_target = input(This target is too far away, please select another target)
    targets.append(new_target)

for i in targets:
  new_target = make_class(targets.pop(0))
  new_reaction = input(new_target + ", how do you react?")

  result = attack(source,"Weapon Attack",new_target,new_reaction)

  if result == "Critical":
    damage(target2,weapons_dict[weapon]["Crit_Damage"])
  elif result == "Fail":
    print("Sorry you Suck")
  elif result == 'Critical Fail':
    print("You really suck bad")
  else:
    exec(actions_dict[action]["Payload"])
         '''
      },
      3:{
          "Description":"You can attempt to hit 5 targets. All targets will roll reactions against the same attack roll. Crits will sever any limb hit on the first target",
          "Payload":'''
targets = []

while len(targets) < 4:
  confirmation = input("Do you want to attack another target?")
  if confirmation == 'yes':
    new_target = input("Who would you like to target?)
    
    if distance(source,new_target) != 1:
      while distance(source,new_target) != 1:
        new_target = input(This target is too far away, please select another target)
    targets.append(new_target)

for i in targets:
  new_target = make_class(targets.pop(0))
  new_reaction = input(new_target + ", how do you react?")

  result = attack(source,"Weapon Attack",new_target,new_reaction)

  if result == "Critical":
    damage(target2,weapons_dict[weapon]["Crit_Damage"])
  elif result == "Fail":
    print("Sorry you Suck")
  elif result == 'Critical Fail':
    print("You really suck bad")
  else:
    exec(actions_dict[action]["Payload"])
         '''
      }
    },
    "Concussion":{
      "Info":"String",
      1:{
          "Description":"String",
          "Payload":'''

         '''
      },
      2:{
          "Description":"String",
          "Payload":'''

         '''
      },
      3:{
          "Description":"String",
          "Payload":'''

         '''
      }
    },
    "Crush":{
      "Info":"String",
      1:{
          "Description":"Successful attacks will also add 1 stage of Crippled to the target",
          "Payload":'''
status(target,"Crippled",1)
         '''
      },
      2:{
          "Description":"Successful attacks will also add 2 stages of Crippled to the target",
          "Payload":'''
status(target,"Crippled",2)
         '''
      },
      3:{
          "Description":"Successful attacks will also add 3 stages of Crippled to the target",
          "Payload":'''
status(target,"Crippled",3)
         '''
      }
    },
    "Distance":{
      "Info":"String",
      1:{
          "Description":"You can choose take a -5 to hit to double your range",
          "Pre_Action":'''
source.misc_bonus -= 5
source.Equipment["Main Hand"]["Range"] *= 2
          ''',
          "Post_Action":'''
source.misc_bonus += 5
source.Equipment["Main Hand"]["Range"] /= 2
          ''',
          "Payload":'''
source.Pre_Action.update(Distance = techniques_dict["Distance"][1]["Pre_Action"])
source.Post_Action.update(Distance = techniques_dict["Distance"][1]["Post_Action"])
         '''
      },
      2:{
          "Description":"You can choose take a -2 to hit to double your range, or take a -5 to hit to triple your range",
          "Pre_Action":'''
source.misc_bonus -= 5
source.Equipment["Main Hand"]["Range"] *= 3
          ''',
          "Post_Action":'''
source.misc_bonus += 5
source.Equipment["Main Hand"]["Range"] /= 3
          ''',
          "Payload":'''
source.Pre_Action.update(Distance = techniques_dict["Distance"][2]["Pre_Action"])
source.Post_Action.update(Distance = techniques_dict["Distance"][2]["Post_Action"])
         '''
      },
      3:{
          "Description":"You can double your range or you can choose take a -2 to hit to triple your range",
          "Pre_Action":'''
source.misc_bonus -= 2
source.Equipment["Main Hand"]["Range"] *= 3
          ''',
          "Post_Action":'''
source.misc_bonus += 2
source.Equipment["Main Hand"]["Range"] /= 3
          ''',
          "Payload":'''
source.Pre_Action.update(Distance = techniques_dict["Distance"][3]["Pre_Action"])
source.Post_Action.update(Distance = techniques_dict["Distance"][3]["Post_Action"])
         '''
      }
    },
    "Flurry":{
      "Info":"String",
      1:{
          "Description":"Consecutive attacks in the same turn cost -1 AP after the first",
          "Payload":'''
weapon = source.Equipment["Main Hand"]
source.AP -= (weapons_dict[weapon]["AP"] - 1)

reaction2 = input(target.Name + ", how do you react?")

result = attack(source,"Weapon Attack",target,new_reaction)

if result == "Critical":
  damage(target2,weapons_dict[weapon]["Crit_Damage"])
elif result == "Fail":
  print("Sorry you Suck")
elif result == 'Critical Fail':
  print("You really suck bad")
else:
  exec(actions_dict[action]["Payload"])
         '''
      },
      2:{
          "Description":"Consecutive attacks in the same turn cost -2 AP after the first",
          "Payload":'''
weapon = source.Equipment["Main Hand"]
source.AP -= (weapons_dict[weapon]["AP"] - 2)

reaction2 = input(target.Name + ", how do you react?")

result = attack(source,"Weapon Attack",target,new_reaction)

if result == "Critical":
  damage(target2,weapons_dict[weapon]["Crit_Damage"])
elif result == "Fail":
  print("Sorry you Suck")
elif result == 'Critical Fail':
  print("You really suck bad")
else:
  exec(actions_dict[action]["Payload"])
         '''
      },
      3:{
          "Description":"Consecutive attacks in the same turn cost -3 AP after the first",
          "Payload":'''
weapon = source.Equipment["Main Hand"]
source.AP -= (weapons_dict[weapon]["AP"] - 3)

reaction2 = input(target.Name + ", how do you react?")

result = attack(source,"Weapon Attack",target,new_reaction)

if result == "Critical":
  damage(target2,weapons_dict[weapon]["Crit_Damage"])
elif result == "Fail":
  print("Sorry you Suck")
elif result == 'Critical Fail':
  print("You really suck bad")
else:
  exec(actions_dict[action]["Payload"])
         '''
      }
    },
    "Impact":{
      "Info":"String",
      1:{
          "Description":"Each attack adds a 1 stage of Momentum",
          "Payload":'''
status(source,"Momentum",1)
         '''
      },
      2:{
          "Description":"Each attack adds a 2 stages of Momentum",
          "Payload":'''
status(source,"Momentum",2)
         '''
      },
      3:{
          "Description":"Each attack adds a 3 stages of Momentum",
          "Payload":'''
status(source,"Momentum",3)
         '''
      }
    },
    "Pin Point":{
      "Info":"String",
      1:{
          "Description":"String",
          "Pre_Action":'''
bonus = roll_dice(1,6,0,21)
source.temp_bonus += bonus
          ''',
          "Post_Action":'''

          ''',
          "Payload":'''
source.Pre_Action.update("Pin Point" = techniques_dict["Pin Point"][1]["Pre_Action"])
         '''
      },
      2:{
          "Description":"String",
          "Pre_Action":'''
bonus = roll_dice(1,10,0,21)
source.temp_bonus += bonus
          ''',
          "Post_Action":'''

          ''',
          "Payload":'''
source.Pre_Action.update("Pin Point" = techniques_dict["Pin Point"][2]["Pre_Action"])
         '''
      },
      3:{
          "Description":"String",
          "Pre_Action":'''
bonus = roll_dice(1,20,0,21)
source.temp_bonus += bonus
          ''',
          "Post_Action":'''

          ''',
          "Payload":'''
source.Pre_Action.update("Pin Point" = techniques_dict["Pin Point"][3]["Pre_Action"])
         '''
      }
    },
    "Rend":{
      "Info":"String",
      1:{
          "Description":"Each attack adds 1 stage of Bleeding",
          "Payload":'''
status(target,"Bleeding",1)
         '''
      },
      2:{
          "Description":"Each attack adds 2 stages of Bleeding",
          "Payload":'''
status(target,"Bleeding",2)
         '''
      },
      3:{
          "Description":"Each attack adds 3 stages of Bleeding",
          "Payload":'''
status(target,"Bleeding",3)
         '''
      }
    },  
}

features_dict = {
    "Name":{
        "Description":"String",
        "Pre_Action":'''

          ''',
        "Post_Action":'''

          ''',
        "Equip":'''

        ''',
        "Unequip":'''

        '''
    },
    "Dual Wielding":{
        "Description":"You can use this weapon in your Off Hand (if available) and attack for -1 AP but with no Techinques. ",
        "Pre_Action":'''
weapon = input("Do you want to use your\n" +  source.Equipment["Main Hand"] + "\n or your\n" + source.Equipment["Off Hand"])
          ''',
        "Equip":'''
if slot == "Off Hand":
  source.Equipment[slot][item]["AP"] -= 1
  source.Equipment[slot][item]["Techniques] = {}

  source.Pre_Action.update("Dual Wielding" = features_dict["Dual Wielding"]["Pre_Action"])
        ''',
        "Unequip":'''
source.Pre_Action.pop("Dual Wielding")
        '''
    },
    "Dueling":{
        "Description":"You can perform Feint, Parry, Riposte, and Disarm for -1 AP/RP respectively. ",
        "Pre_Action":'''
if action == "Feint" or "Disarm":
  source.AP += 1
          ''',
        "Pre_Reaction":'''
if reaction == "Parry" or "Riposte":
  source.RP += 1
          ''',
        "Equip":'''
source.Pre_Action.update(Dueling = features_dict["Dueling"]["Pre_Action"])
source.Pre_Reaction.update(Dueling = features_dict["Dueling"]["Pre_Reaction"])
        ''',
        "Unequip":'''
source.Pre_Action.pop("Dueling")
source.Pre_Reaction.pop("Dueling")
        '''
    },
    "Finesse":{
        "Description":"You can Replace your Muscle skill with your Finesse Skill",
        "Pre_Action":'''
if action == "Weapon Attack":
  source.misc_bonus -= mods(source.Attributes["STR"])
  source.misc_bonus -= source.Skills["Muscle"]

  source.misc_bonus += mods(source.Attributes["DEX"])
  source.misc_bonus += source.Skills["Finesse"]
          ''',
        "Post_Action":'''
if action == "Weapon Attack":
  source.misc_bonus -= mods(source.Attributes["DEX"])
  source.misc_bonus -= source.Skills["Finesse"]

  source.misc_bonus += mods(source.Attributes["STR"])
  source.misc_bonus += source.Skills["Muscle"]
          ''',
        "Equip":'''
source.Pre_Action.update(Finesse = features_dict["Finesse"]["Pre_Action"])
source.Post_Action.update(Finesse = features_dict["Finesse"]["Post_Action"])
        ''',
        "Unequip":'''
source.Pre_Action.pop("Finesse")
souce.Post_Action.pop("Finesse")
        '''
    },
    "Grappling":{
        "Description":"You can perform Wrestle checks with this weapon against a target",
        "Pre_Action":'''

          ''',
        "Post_Action":'''

          ''',
        "Equip":'''

        ''',
        "Unequip":'''

        '''
    },
    "Heavy":{
        "Description":"You can use 2 techniques per attack",
        "Pre_Action":'''

          ''',
        "Post_Action":'''

          ''',
        "Equip":'''

        ''',
        "Unequip":'''

        '''
    },
    "Light":{
        "Description":"Doesn't damage Heavy armors Durability",
        "Post_Roll":'''
if action == "Weapon Attack":
  target_armor = target.Equipment["Armor"]
  if target_armor["Type"] == "Heavy":
    target.Equipment["Armor"][target_armor]["Durability"] += 1
          ''',
        "Equip":'''
source.Post_Roll.update(Light = features_dict["Light"][Post_Roll])
        ''',
        "Unequip":'''
source.Post_Roll.pop("Light")
        '''
    },
    "Thrown":{
        "Description":"You can add 1 stage of momentum to your impact equation when you attack with this weapon at range.",
        "Pre_Action":'''
range = distance(source,target)
if action == "Weapon Attack" and range > 1:
  status(source,momentum,1)
          ''',
        "Post_Action":'''
if action == "Weapon Attack" and range > 1:
  status(source,momentum,-1)
          ''',
        "Equip":'''
source.Pre_Action.update(Thrown = features_dict["Thrown"]["Pre_Action"])
source.Post_Action.update(Thrown = features_dict["Thrown"]["Post_Action"])
        ''',
        "Unequip":'''
source.Pre_Action.pop("Thrown")
source.Post_Action.pop("Thrown")
        '''
    },
    "Versatile":{
        "Description":"You can use the weapon as a Piercing or Slashing weapon.",
        "Pre_Action":'''

if action == "Weapon Attack":
  choice = input("Do you want to use slashing or piercing?")

  if choice == "slashing":
    source.Equipment[weapon]["Type"] = "Slashing"
  else:
    source.Equipment[weapon]["Type"] = "Piercing"
          ''',
        "Equip":'''
source.Pre_Action.update(Versatile = features_dict["Thrown"]["Pre_Action"])

        ''',
        "Unequip":'''
source.Pre_Action.pop("Versatile)
        '''
    },
    
}

#classes

classes_dict = {
    "Name":{
        "Description": "string",
        "Offense Ability": "string",
        "Defense Ability": "string",
        "Mobility Ability": "string",
        "Special Ability": "string"
        },
    "Warrior":{
        "Description": "The warrior is a master battlefield technician. They specialize in bringing the fight to them and using defense as a weapon.\n\u2022 A group of minotaurs surround a single fighter. The leader charges in, confident he can overpower the small framed woman with nothing but a sword and shield. He raises back his maul and charges forward with a sure hit in his eye. The woman tilts forward and like a well timed dance, glances the maul off her shield and burries her sword in its unprotected abdomen. The three other minotaurs fume at her as she plants her sword through their leader's haunch, confirming her kill. They rush forward at once to avenge their fallen comrade, the woman raises her shield again lowers her frame. The last thing they see is fire in her eye and a smirk on her lips. ",
        "Offense Ability": "Bring It On - Unused AP is automatically converted to RP until the beginning of your next turn. ",
        "Defense Ability": "Expanded Reactions - You can perform any action as a reaction (using RP instead of AP) if the trigger is either:\n    \u2022 A target moves through a space adjacent to you OR\n    \u2022 You are selected for the target of an attack",
        "Mobility Ability": "Center of Attention - +1 to all your reactions reactions for each enemy adjacent to you.",
        "Special Ability": "Improved Taunt - You can Taunt 2 targets with a single action"
        },
    "Brute":{
        "Description": "A chaotic powerhouse on the battlefield, a brute fears nothing and knows that the strongest defense is a good offense. They are savages on the battlefield, dealing damage as much as possible as strong as possible.\n\u2022 The witch doctor lies on an army of corpses. Only one man opposes him. He believes that the single axe is no match for his army of undead and raises the horde to send a wave in.  One after another they fall, slit in half by the axe, He summons more, and more but the barbarian keeps swinging, and he is moving toward the mage. Corpse after corpse after corpse, battered broken and beaten. Inch by inch, swing by swing, the man moves closer. The undead are in a perpetual state of raising themselves back up from their remade graves. The axe is moving faster with each strike and the berserker wielding it now taking down multiple with with each swing. The necromancer starts to understand the gravity of the situation. Their is no army that can stop him.",
        "Offense Ability": "Relentless - Each consecutive attack lowers the Crit Threshold by 1. Crit Threshold restores to 20 on a Crit or missed attack.",
        "Defense Ability": "Grit - As a reaction, you can move a health tier by the Capacity of the incoming attack. Your health tiers restore at the start of your next turn (before healing).",
        "Mobility Ability": "Unstoppable Force - You can +1 to your Size (in the Force equation) for each stage of Momentum you have.",
        "Special Ability": "Opportunity Attack - You can replace the Trip Effect with an Attack action (STR Mod)\n    \u2022 Altered Trip"
        },
    "Ranger":{
        "Description": "Mobility is a Ranger's life. It is their primary weapon and their focus of their attack on their enemies. A ranger doesn't fire at the heart, but at the legs, surgically removing them as a threat on the battlefield.\n\u2022 A young pirate hauls his spoils to shore with his fellow marauders. Suddenly, an arrow breaks their concentration, piercing through a comrade's leg. The group turns to see a lone ranger up the shore. Racing forward the pirates charge the assailant. One by one arrows pick off the chargers until only the young pirate and 4 others remain. The archer stows his bow and draws twin blades before rushing toward the last of them. His movement is water in a bowl, sliding under one and spinning around another. The young man sees the futility of the fight and turns to flee for his life. The battlefield is strewn with crawling soon to be corpses trying to drag them selves away. He doesn't get 10 steps before a thrown dagger plunges in his thigh. He turns to see the avatar of his fate casually cleaning up what is left of the pirates. There is no escape.",
        "Offense Ability": "Stunt Attacks - If you use Maneuver while attacking, you can add 1 stage of any Position to either you or the target (your choice) for the duration of the attack.",
        "Defense Ability": "Safe Distance - If an enemy moves within their Attack range of you, you can move away as a reaction (1 RP per yard).",
        "Mobility Ability": "Maneuver - You can move while performing other actions. The free movement can be up to half the action's AP Cost.",
        "Special Ability": "Expanded Equipment Slots - You gain three additional slots to have equipped in combat."
        },
    "Rogue":{
        "Description": "A Rogue doesn't mince words, movement, or attacks. They target the vital points of their targets, slip into the shadows, and strike with lethal precision on their unsuspecting victims.\n\u2022 The cyclops swings its mighty club at the nimble assailant, leveling a building with his missed attack. He looks around for the remnants of the thief but sees nothing but a cloud of black smoke. 'You and your eye share a common weakness.' The cyclops pivots to see his enemy standing up the hill from him. 'That size makes gives you an advantage.' Enraged and rampant, the behemoth charges at him. The rogue draws his bow and waits as the cyclops fills his view. At the last moment, he lets loose his arrow, sinking it deep in the giant's eye. His body goes limp and he falls on the stagnant rogue, smothering the spot where he stood and blowing out another cloud of black smoke and dust. 'You see a strength,' The rogue jests as he steps out of a nearby shadow, 'I see a target.'",
        "Offense Ability": "Dead Eye - You gain double effect from the Aim Action. On a success, you also gain the benefit of Enemy Status or Vital Scan on a single target.\n    \u2022 Altered Aim",
        "Defense Ability": "Tuck and Roll - After a Dive, you can perform a Coordination(DC 10) check to avoid landing Prone.\n    \u2022 Altered Dive",
        "Mobility Ability": "Back Stab - You can move behind a target to give the target an additional stage of Flanked",
        "Special Ability": "Shadow Step - If you are Hidden 3 to all enemies, you can use the Acrobatics check to teleport to another hidden location. \n    \u2022 Altered Acrobatics"
        },
    "Druid":{
        "Description": "A Druid is one who has an inseparable connection to nature and life. They are gifted with animal forms, the controlling weather, and calling bestial spirits to aid them.\n\u2022 The wind whips past the trees almost making a pitch, like an ancient whistle from an unknown age. 'We can always smoke you out!' The three wild men call out. They stand at the edge of a forest with lit torches. A stag steps forward. 'Now you'll come with us peaceably so we won't have to resort to fire.' The stag charges at them ramming its points into the first man, who coughs up blood as he drops to the floor. His torch begins to light the brush on fire. The second man fires an arrow that rips into the deer. Instantaneously it transforms into a falcon what dives after him, shifting into a bear that slams into him, his claws make sort work of the archer. The bear lifts its blood soaked head from the corpse to see the final man who is raising his torch above a barrel. The fire blazed behind the bear as it shifts into a youthful woman, the arrow still in her side. She sings a peaceful note that seems to be carried on the wind as her eyes flood in a bright white hue. The warrior moves his hand to the barrel but he is cut off as spectral wolves rip his body apart. The druid's song ends as the rain picks up where she left off, dousing the growing flames back to ash.",
        "Offense Ability": "Hunter Form - You gain a Hunter Form for Transform",
        "Defense Ability": "Defender Form - You gain a Defender Form for Transform. You can use the Transform action to transform into your Defender form as a reaction for 4 RP",
        "Mobility Ability": "Sprinter Form - You gain a Sprinter Form for Transform. If you are moving in a straight line, you can Transform into your Sprinter form for 4 movement and or AP.",
        "Special Ability": "Partial Polymorph - You can perform an Improvise(DC 10) check to gain one of the actions or bonuses from one of your forms for the following action."
        },
    "Sorcerer":{
        "Description": "A Sorcerer is a wielder of elemental power able to cast spells and attacks from one of the elements they are attuned to: Light, Wind, Nature, Water, Earth, Fire, and Lightening. They can either bend the element to their will turning the battled field against their opponents, or create it them selves in ever greater and more powerful ways\n\u2022 The ship tossed violently on the water, the merfolk glared their thin razor teeth at the crew as they clawed aboard. The passengers huddled together and prayed, not knowing what could save them. A scarred woman stepped forward. Burned skin from the years of mistakes trace down to her hands that seem to be holding chaotic orbs of fire, barely able to be contained. The Merfolk rush in, not afraid of the fire in such a place. The Sorceress lets out a flare of fire at the first, melting its skin on contact. A fiery figure of a hand from the first to the second, mirroring the movement of her own hand as the flames consume the second. The final merfolk races toward her trying to throw her off guard, but is met with a fiery dagger that impales it. Stepping back, it realizes that the wound is not that deep and regains its confidence. It is about to lunge forward when the sorceress snaps her fingers causing an explosion to set off from the dagger that impaled still lodged in the assailant. Whats left of his corpse drops to the ground.",
        "Light":{
            "Offense Ability": "Light - Emboldening Light - You can amplify a light source to perform a Light attack against all targets looking at it\nDark - Amplified Shadows - You can amplify the darkness in any shadow or not directly lit area giving a stage of Blinded and Hidden to all targets within",
            "Defense Ability": "Light - Mirage -  You can bend light around a target within your attack range to make them harder to see. Perform a Feint check and replace the effect. New effect: Target gains a stage of Cover and all attackers against the target gain a stage of Confused.",
            "Mobility Ability": "Light - Pinpoint - You can perform Find Vitals check to illuminate the vital points of a target as long as you maintain eyesight on them. On a success, all Vital Attacks against the target can add your CHA Mod\nDark - Pitch Black- For each stage of Cover you have within range of a Blinded 3 target, the target minuses your CHA Mod from their reactions.",
            "Special Ability": "Light - Revitalize - You can perform a Encourage check to heal a target up to the top of its current Health Tier\nDarkness - Long Night - You can perform a Pacify check to prevent a target from Healing at the top of their turn."
        },
        "Wind":{
            "Offense Ability": "Gust - If you have 2 Elemental Weapons, you can create a constant wind between the two while you are within range. And creature moving through or ending their turn in this wind will take the Shove action and any object between passing between the two will take the Throw action with your CHA mod worth of Force units. Once either weapon performs another action, the Gust ends.",
            "Defense Ability": "Head wind - You can perform a Parry check to veer an incoming attack with wind. On a success, the target subtracts the difference from their attacks for the rest of their turn.",
            "Mobility Ability": "Tailwind - When you Lunge, you gain 2 stages of Momentum and can move up to 5 yards away.",
            "Special Ability": "Billow - You can perform a Battlefield(DC=10) to increase the Momentum of Wind by 1 stage in a direction for 1 turn. (Diagonally or Orthogonally only)"
        },
        "Nature":{
            "Offense Ability": "Seeded - On a successful attack from your Elemental Weapon, you can seed a target. At the start of the players 2nd turn from this, you can attempt a Grapple check for 0 AP against the targeted area",
            "Defense Ability": "Trees - Adaptive armor that adds your CHA Mod to Defend and on saves verse External status effects",
            "Mobility Ability": "Vines - You can animate a vine to perform a grapple check. On a success (or a willing target), the target can be pulled to any spot within the vine's range.",
            "Special Ability": "Brush - You can plant a delayed effect through seeds. In two turns the seeds will sprout to perform 2 +5 Wrestle checks. "
        },
        "Water":{
            "Offense Ability": "Water - Water Torture - After a successful attack, you can perform a Choke check for 2 AP.\nIce - Numbing - On every successful attack, the target must make a (DC 10 + number of attacks in combat) Vitality check. On a fail they take a stage of Fatigued",
            "Defense Ability": "Water - Fluid movement - Can use water to perform a Dive check but without moving outside your current position.\nIce - Slick - Can perform a Trip check by putting ice in a targets path out to a range of 4 yards.",
            "Mobility Ability": "Walk on water- You can move on the surface of water.",
            "Special Ability": "Flash Freeze - You can use an Improvise check to instantly turn one Size unit of any Freezable material to ice."
        },
        "Earth":{
            "Offense Ability": "Shaky Ground - Every successful attack against an enemy allows you to make a Shove check for 2 AP",
            "Defense Ability": "Stone - Stone Shield - You can Encase yourself in stone to receive +5 on a Defend check.",
            "Mobility Ability": "Sand - Sand Surfing - You can move through sand while maintaining Hidden.",
            "Special Ability": "Turf - Earthen Clay - Can mold 5 cubic feet of earth within range to perform any STR or DEX Action (except for coordination checks) but using your CHA Mod."
        },
        "Fire":{
            "Offense Ability": "Blaze - You can consume Burning statuses to fuel a stronger Attack. For each stage stage of Burning you consume within range, your next attack can have +1 Capacity \n     \u2022Additionally you can fuel higher power rank special moves equal to 1 power rank per Burning status",
            "Defense Ability": "Burning Rebuke - You can replace the Parry Effect to add a stage of Burning to the attacker for every damage or status you take in the attack.\n    \u2022 Altered Parry",
            "Mobility Ability": "Heart of the Fire - Each Burning status within 3 yards of you adds one success toward your power rank. If they are extinguished, you lose 1 power rank for each square extinguished.",
            "Special Ability": "Detonate - You can perform an Improvise(DC 10) consume one Burning status within attack range to charge an inanimate object you touch with energy which will explode in 1 turn consuming the object and propelling your CHA mod worth of Force Units in a radius."
        },
        "Lightning":{
            "Offense Ability": "Chain Lightning - On a successful Attack (or if the target uses Defend) you can perform a Taunt check to turn the target into an Elemental weapon.",
            "Defense Ability": "On a successful Defend or Parry against a melee attack, you can add a stage of Stunned to the target.",
            "Mobility Ability": "You can charge your elemental weapon by moving 3 yards.",
            "Special Ability": "You can charge a Conductive object within your range. The first three targets that walk through the range of the object must roll a Concentration check or become an Elemental Weapon."
        }
    
    },
    "Arcanist":{
        "Description": "Unlike sorcerers who bend the elements after being imbued with power from them, Arcanists hunt for magic to command the dormant power in everything from the human mind to gravity itself. They are accustomed to seeing unorthodox solutions to problems by manipulating the forces of matter, gravity, mind, and spirit.\n\u2022 The drake stares down the only enemy left, a feeble scholarly looking young man holding only a dagger. The man's four companions lie on the ground around him. The drake circles him, almost toying with his prey. Bringing the blade to his hand, the man tears it into his own flesh. Blood glows a faint red on the blade as the scholar's eyes light in an incandescent hue. The four compatriots rise from their grave and rush at the drake, their undead forms racing forward with vicious speed. Battering them away, the drake preps his fiery breath. An unearthly chanting can be heard, speaking from the ground as the dragonling's fire blasts out incinerating one of the undead. It screams in pain as another's spear slashes into its side. It can barely react before milky dark tentacles erupt from the ground, binding it as they coil around its limbs. Looking at the scholar now walking to it calmly, fear floods over its pinned frame. The feeble man utters an unknown tongue as he jabs the blade into his stomach, never flinching. Ghostly fingers wreath the man's hand in a spectral flame as he plants it on the skull of the beast. It's hatred slowly burns away, replaced with apathy, and then eventually, loyalty and love. The tentacles fade away, as they are no longer needed. The beast bows to its new master.",
        "Mind":{
            "Offense Ability": "Mental Torture - You can perform an altered Distract check to attempt to damage a target with a mental status. On a success, erase the mental status of the target. For each stage of statuses erased, the target takes 1 damage.",
            "Defensive Ability":"Illusionary Duplicate - You can perform an altered Dive check that leaves an illusionary copy of yourself in your place. This copy can only perform the Taunt action and Dodge reaction. Once this illusion is hit with an attack, it disappears. You can only have one duplicate at a time. a successful Defend or Parry against a melee attack, you can add a stage of Stunned to the target.",
            "Mobility Ability": "Dominate Mind - You can perform a Pacify/Taunt check to dominate the mind of one living creature you touch. On a success, the target is gains a stage of Confused  and it under your control until they Crit Fail. As long as the target is Confused, their stage of confused is equal to their distance from you in yards (max 3)\n    \u2022 Altered Pacify/Taunt",
            "Special Ability": "Memory Loss - You can replace the Effect of Feint  to make a character forget the last round of combat and they take the Mental statuses and disposition they had at the beginning of their previous round."
        },
        "Matter":{
            "Offense Ability": "Transmutation - You can perform an Improvise(DC 10) check to change the physical matter of one inanimate object that you touch as long as you maintain touch with it. It retains its shape but upon letting go it will revert to the original material and location.",
            "Defensive Ability":"Enlarge - You can replace the Effect of Dive  with an Enlarge reaction to double the size of any inanimate object you touch (doubled size must be no more than 1 size unit). This grants you at least 1 stage of Cover while behind it. The target reverts at the beginning of your next turn.",
            "Mobility Ability": "Phase - You can Phase through solid objects. You can Phase through 1 size unit of material for each stage of Momentum that you have. If the size is too large, you will collide with the exterior of the object and take Damage from the Impact.",
            "Special Ability": "Partial Transmutation - You can perform an Improvise check to transmute a material you touch with one property of another material you see within range. The change lasts for the turn."
        }, 
        "Gravity":{
            "Offense Ability": "Propel - You can Shove/Throw a target in range with your INT mod worth of Force Units. On a success, the target is considered Thrown.",
            "Defensive Ability":"Hold - You can Parry  with gravity to stop a physical attack against you. On a success you can evade the attack and, if it is a weapon attack, attempt a free Disarm check. If the Disarm is successful, you can pull the weapon to you and equip it in a free hand.",
            "Mobility Ability": "Hover - If you Levitate yourself, you can Leap to move yourself up to your INT mod worth of yards and gaining a Momentum stage for every 2 squares moved.",
            "Special Ability": "Levitate - You can replace the Effect of Grapple to lift a target with your INT Mod +2 worth of Force Units until the start of their next turn (replace Range with your Attack range). On a success, gravity no longer affects the target and its weight units are reduced to 1 for the purpose of Impact. Additionally the target can only move by performing Acrobatics checks on objects within reach or by external Force being pushed against it. \n    \u2022 Altered Grapple"
        }, 
        "Spirit":{
            "Offense Ability": "Possession - You can use an Encourage check send a willing spirit into a lifeless form to possess it and operate through it.",
            "Defensive Ability":"Retribution - You can perform a Parry check to take any damage and/or status you suffer and mirror it back on the attacker two fold.",
            "Mobility Ability": "Graveyard - You can perform a Bandage check on a creature that died in the past minute and heal all of your missing Health Blocks (broken Health tiers are unaffected).",
            "Special Ability": "Not Forgotten - You can perform a Pacify/Taunt check on the spirit of any creature that died in the past minute. On a success, they become a willing spirit."
        }
    }
}

# statuses

statuses_dict = {
    "Name":{
        "Type": "string(status types)",
        "Description":"string",
        "Stage1": "string",
        "Stage2": "string",
        "Stage3": "string",
        "Interrupt":{
            'Pre_Action':{
              1:'''
              
              ''',
              2:'''
              
              ''',
              3:'''
              
              '''
            }
        },
        "Payload":{
            0:"print('0')",
            1:"print('1')",
            2:"print('2')",
            3:"print('3')"
        }
    },
    "Bleeding":{
        "Type": "Physical",
        "Description":"Losing Blood\n  \u2022 Removal - Bandage(self/ally) check to douse. RDC",
        "Stage1": "\u2022 Take 1 damage at the beginning of the next turn (after regen)",
        "Stage2": "\u2022 Take 2 damage at the beginning of the next turn. (after regen)",
        "Stage3": "\u2022 Take 3 damage at the beginning of the next turn. (after regen)",
        "Interrupt":{
            'Pre_Action':{
              1:'''
              
              ''',
              2:'''
              
              ''',
              3:'''
              
              '''
            }
        },
        "Payload":{
            0:'''
target.Open_Phase.pop("Bleeding")
            ''',
            1:'''
if "Bleeding" in target.Open_Phase:
  target.Open_Phase.pop("Bleeding")
target.Open_Phase.update(Bleeding = "damage(target,1)")
            ''',
            2:'''
if "Bleeding" in target.Open_Phase:
  target.Open_Phase.pop("Bleeding)")

target.Open_Phase.update(Bleeding = "damage(target,2)")
            ''',
            3:'''
target.Open_Phase.pop("Bleeding")
target.Open_Phase.update(Bleeding = "damage(target,3)")
            ''',
            4:"print('permanantly bleeding')"
        }
        #blinded can't take into account whether the target is attacking from ranged during the attack action. 
    },
    "Blinded":{
        "Type": "Physical",
        "Description":"Impaired vision\n  \u2022 Removal - Bandage(ally)/Recover(self) check RDC.",
        "Stage1": "\u2022 -2 Attack",
        "Stage2": "\u2022 -5 Attack\n  \u2022 -5 Reactions vs Ranged attacks",
        "Stage3": "\u2022 -10 Attack\n  \u2022 -10 Reactions vs Ranged attacks",
        "Interrupt":{
            "Pre_Action":{
              1:'''
if actions_dict[action]["Action_Type"] == "Attack":
  target.misc_bonus -= 2
              ''',
              2:'''
if actions_dict[action]["Action_Type"] == "Attack":
  target.misc_bonus -= 5
              ''',
              3:'''
if actions_dict[action]["Action_Type"] == "Attack":
  target.misc_bonus -= 10
              '''             
            },
            "Pre_Reaction":{
              1:None,
              2:'''
if distance(source,target) > 1:
  target.misc_bonus -= 5
              ''',
              3:'''
if distance(source,target) > 1:
  target.misc_bonus -= 10
              '''
            },
            "Post_Action":{
              1:'''
if actions_dict[action]["Action_Type"] == "Attack":
  target.misc_bonus += 2
              ''',
              2:'''
if actions_dict[action]["Action_Type"] == "Attack":
  target.misc_bonus += 5
              ''',
              3:'''
if actions_dict[action]["Action_Type"] == "Attack":
  target.misc_bonus += 10
              '''              
            },
            "Post_Reaction":{
              1:None,
              2:'''
if distance(source,target) > 1:
  target.misc_bonus -= 5
              ''',
              3:'''
if distance(source,target) > 1:
  target.misc_bonus -= 10
              '''
            }
        },
        "Payload":{
            0:'''
target.Pre_Action.pop("Blinded")
target.Post_Action.pop("Blinded")
target.Pre_Reaction.pop("Blinded")
target.Post_Reaction.pop("Blinded")
            ''',
            1:'''
if 'Blinded' in target.Pre_Action:
  target.Pre_Action.pop("Blinded")
  target.Post_Action.pop("Blinded")
  target.Pre_Reaction.pop("Blinded")
  target.Post_Reaction.pop("Blinded")

target.Pre_Action.update(Blinded = statuses_dict['Blinded']['Interrupt']['Pre_Action][1])
target.Post_Action.update(Blinded = statuses_dict['Blinded']['Interrupt']['Post_Action][1])
            ''',
            2:'''
target.Pre_Action.pop("Blinded")
target.Post_Action.pop("Blinded")
target.Pre_Reaction.pop("Blinded")
target.Post_Reaction.pop("Blinded")

target.Pre_Action.update(Blinded = statuses_dict['Blinded']['Interrupt']['Pre_Action][2])
target.Pre_Reaction.update(Blinded = statuses_dict['Blinded']['Interrupt']['Pre_Reaction][2])
target.Post_Action.update(Blinded = statuses_dict['Blinded']['Interrupt']['Post_Action][2])
target.Post_Reaction.update(Blinded = statuses_dict['Blinded']['Interrupt']['Post_Reaction][2])
            ''',
            3:'''
target.Pre_Action.pop("Blinded")
target.Post_Action.pop("Blinded")
target.Pre_Reaction.pop("Blinded")
target.Post_Reaction.pop("Blinded")

target.Pre_Action.update(Blinded = statuses_dict['Blinded']['Interrupt']['Pre_Action][3])
target.Pre_Reaction.update(Blinded = statuses_dict['Blinded']['Interrupt']['Pre_Reaction][3])
target.Post_Action.update(Blinded = statuses_dict['Blinded']['Interrupt']['Post_Action][3])
target.Post_Reaction.update(Blinded = statuses_dict['Blinded']['Interrupt']['Post_Reaction][3])
            ''',
            4:"print('Permanantly Blinded')"
        }
    },

    #burning doesn't add in any burning effect to adjacent targets
    "Burning":{
        "Type": "Situational",
        "Description":"On Fire\n  \u2022  *Flammable objects adjacent to anything Burning must roll a reaction, if applicable (RDC), or take stages of burning equal to the origin of the status - 1. \nRemoval - Auto decrease\n Improvise (self/ally) check to douse. DC determined by GM",
        "Stage1": "\u2022 Take 1 damage at the beginning of the next turn (after regen)",
        "Stage2": "\u2022 Take 2 damage at the beginning of the next turn. (after regen)",
        "Stage3": "\u2022 Take 3 damage at the beginning of the next turn. (after regen)",
         "Interrupt":{
            'Pre_Action':{
              1:'''
              
              ''',
              2:'''
              
              ''',
              3:'''
              
              '''
            }
        },
        "Payload":{
            0:'''
target.Open_Phase.pop("Burning")
            ''',
            1:'''
if "Burning" in target.Open_Phase:
  target.Open_Phase.pop("Burning")
target.Open_Phase.update(Burning = "damage(target,1)")
            ''',
            2:'''
if "Burning" in target.Open_Phase:
  target.Open_Phase.pop("Burning")

target.Open_Phase.update(Burning = "damage(target,2)")
            ''',
            3:'''
target.Open_Phase.pop("Burning")
target.Open_Phase.update(Burning = "damage(target,3)")
            ''',
            4:"print('permanantly burning')"
        }
    },

    #crippled doesn't take into account which arm and it doesn't store them aside from the number
    "Crippled":{
        "Type": "Physical",
        "Description":"Damaged Limbs\n  \u2022 Removal - Bandage(self/ally) check RDC",
        "Stage1": "ARM \u2022 -2 on all actions/reactions with arm\nLEG \u2022 -2 MP and Dodge",
        "Stage2": "ARM \u2022 -5 on all actions/reactions with arm\n\u2022 Ever attack against arm adds a Disarm action\nLEG \n\u2022Double movement Cost and -5 Dodge\n\u2022 Every attack against leg adds a Trip action",
        "Stage3": "ARM \u2022 -10 on all actions/reactions with arm\n\u2022 Ever attack against arm adds a +5 Disarm action\nLEG \n\u2022 Triple movement Cost and -10 Dodge \n\u2022 Every attack against leg adds a +5 Trip action",
         "Interrupt":{
            'Pre_Action':{
              1:'''
              
              ''',
              2:'''
              
              ''',
              3:'''
              
              '''
            }
        },
        "Payload":{
            0:'''
selection = input("Are you targeting an Arm or a Leg?")
            ''',
            1:'''
selection = input("Are you targeting an Arm or a Leg?")
if selection == "Arm":
  target.Attributes["STR"] -= 2
  target.Skills["Finesse"] -= 2
  target.Skills["Sleight"] -= 2
else:
  target.Max_MP -= 2
  target.MP -= 2
  target.Skills["Coordination"] -= 2
            ''',
            2:'''
selection = input("Are you targeting an Arm or a Leg?")
if selection == "Arm":
  target.Attributes["STR"] -= 5
  target.Skills["Finesse"] -= 5
  target.Skills["Sleight"] -= 5
else:
  target.Max_MP -= 5
  target.MP -= 5
  target.Skills["Coordination"] -= 5
            ''',
            3:'''
selection = input("Are you targeting an Arm or a Leg?")
if selection == "Arm":
  target.Attributes["STR"] -= 10
  target.Skills["Finesse"] -= 10
  target.Skills["Sleight"] -= 10
else:
  target.Max_MP = 0
  target.MP = 0
  target.Skills["Coordination"] -= 10
            ''',
            4: "print('permanantly crippled')"
        }
    },

    #deafened doesn't scale if there is any other effect that limits RP
    "Deafened":{
        "Type": "Physical",
        "Description":"Impaired hearing\n  \u2022Removal - Bandage(ally)/Recover(self) check RDC.",
        "Stage1": "\u2022 -1 RP",
        "Stage2": "\u2022 -2 RP\n  \u2022 Attacks from out of sight add a stage of Surprised.",
        "Stage3": "\u2022 -4 RPs. Cannot hear allies or enemies.\n\u2022 Attacks from out of sight add two stages of Surprised",
        "Interrupt":{
          'Pre_Reaction':{
            1:None,
            2:'''
if target.Positions['Flanked'] > 0:
  target.Statuses['Surprised'] += 1
            ''',
            3:'''
if target.Positions['Flanked'] > 0:
  target.Statuses['Surprised'] += 2
            '''
          },
          'Post_Reaction':{
            1:None,
            2:'''
if target.Positions['Flanked'] > 0:
  target.Statuses['Surprised'] -= 1            
            ''',
            3:'''
if target.Positions['Flanked'] > 0:
  target.Statuses['Surprised'] -= 2            
            '''
          }
        },
        "Payload":{
            0:'''

difference = target.Max_RP - target.RP
target.Max_RP = target.Base_RP
target.RP = target.Max_RP - difference
            ''',
            1:'''
if 'Deafened' in target.Pre_Reaction:
  target.Pre_Reaction.pop('Deafened')
  target.Post_Reaction.pop('Deafened')

difference = target.Max_RP - target.RP
target.Max_RP = target.Base_RP
target.RP = target.Max_RP - difference
target.Max_RP -= 1
target.RP -= 1

            ''',
            2:'''
if 'Deafened' in target.Pre_Reaction:            
  target.Pre_Reaction.pop('Deafened')
  target.Post_Reaction.pop('Deafened')

target.Pre_Reaction.update(Deafened = statuses_dict['Deafened']['Interrupt'][Pre_Reaction][2])
target.Post_Reaction.update(Deafened = statuses_dict['Deafened']['Interrupt'][Post_Reaction][2])


difference = target.Max_RP - target.RP
target.Max_RP = target.Base_RP
target.RP = target.Max_RP - difference
target.Max_RP -= 2
target.RP -= 2
            ''',
            3:'''
target.Pre_Reaction.pop('Deafened')
target.Post_Reaction.pop('Deafened')

target.Pre_Reaction.update(Deafened = statuses_dict['Deafened']['Interrupt'][Pre_Reaction][3])
target.Post_Reaction.update(Deafened = statuses_dict['Deafened']['Interrupt'][Post_Reaction][3])

difference = target.Max_RP - target.RP
target.Max_RP = target.Base_RP
target.RP = target.Max_RP - difference
target.Max_RP -= 3
target.RP -= 3
            ''',
            4:"print('permanently deafened')"
        }
    },

    #fatigued doesn't scale if there is anything else that is limiting AP
    "Fatigued":{
        "Type": "Physical",
        "Description":"Soreness and lack of stamina\n  \u2022 Removal - Recover (self) check RDC",
        "Stage1": "\u2022 +1 AP cost on all actions",
        "Stage2": "\u2022 +2 AP cost on all actions",
        "Stage3": "\u2022 +3 AP cost on all actions",
         "Interrupt":{
            'Pre_Action':{
              1:'''
              
              ''',
              2:'''
              
              ''',
              3:'''
              
              '''
            }
        },
        "Payload":{
            0:'''
difference = target.Max_AP - target.AP
target.Max_AP = target.Base_AP
target.AP = target.Max_AP - difference
            ''',
            1:'''

difference = target.Max_AP - target.AP
target.Max_AP = target.Base_AP
target.AP = target.Max_AP - difference
target.Max_AP -= 1
target.AP -= 1

            ''',
            2:'''
difference = target.Max_AP - target.AP
target.Max_AP = target.Base_AP
target.AP = target.Max_AP - difference
target.Max_AP -= 2
target.AP -= 2

            ''',
            3:'''
difference = target.Max_AP - target.AP
target.Max_AP = target.Base_AP
target.AP = target.Max_AP - difference
target.Max_AP -= 3
target.AP -= 3

            ''',
            4:"print('permanently fatigued')"
        }
    },

    # I need to make a way to separate arms and legs
    "Impaled":{
        "Type": "Situational",
        "Description":"Lodged fragments or shrapnel in body\n  \u2022 Removal - Bandage(self/ally) check RDC\n    \u2022 Failed Bandage Check Adds a stage of Bleeding or Crippled",
        "Stage1": "\u2022 Take 1 damage for every 2 actions of the impaled limb",
        "Stage2": "\u2022 Take 1 damage for every action of the impaled limb",
        "Stage3": "\u2022 Take 2 damage for every action of the impaled limb",
         "Interrupt":{
            'Post_Action':{
              1:'''
target_finesse = roll(target,target.crit_threshold,target.crit_fail_threshold) + target.Skills['Finesse'] + target.Attributes['DEX']

if target_finesse < 11:
  print('You suffer from your impaled limb and take 1 damage')
  damage(target)
else:
  print("You manage to move through your impaled limb with your finesse.\nYou don't take any damage... This time")
              ''',
              2:'''
if actions_dict[action]['Stat'] == 'STR' or 'DEX' or 'CON':
  damage(target)
              ''',
              3:'''
if actions_dict[action]['Stat'] == 'STR' or 'DEX' or 'CON':
  damage(target,2)              
              '''
            }
        },
        "Payload":{
            0:'''
target.Post_Action.pop('Impaled')
            ''',
            1:'''
if 'Impaled' in target.Post_Action:
  target.Post_Action.pop('Impaled')

target.Post_Action.update(Impaled = statuses_dict['Impaled']['Interrupt'][1])
            ''',
            2:'''
target.Post_Action.pop('Impaled')

target.Post_Action.update(Impaled = statuses_dict['Impaled']['Interrupt'][2])
            ''',
            3:'''
target.Post_Action.pop('Impaled')

target.Post_Action.update(Impaled = statuses_dict['Impaled']['Interrupt'][3])
            '''
        }
    },

    # Ready to test
    "Captivated":{
        "Type": "Mental",
        "Description":"Antagonized or focussed on a specific enemy\n  \u2022 Removal - Focus (self)/Encourage (ally) check RDC",
        "Stage1": "\u2022 +1 AP on all actions and movement not directed to the source of the status",
        "Stage2": "\u2022 +2 AP on all actions and movement not directed to the source of the status",
        "Stage3": "\u2022 +3 AP on all actions and movement not directed to the source of the status",
         "Interrupt":{
            'Post_Action':{
              1:'''
if not target_name in source.Captivated_Source:
  source.AP -= 1              
              ''',
              2:'''
if not target_name in source.Captivated_Source:
  source.AP -= 2              
              ''',
              3:'''
if not target_name in source.Captivated_Source:
  source.AP -= 3              
              '''
            }
        },
        "Payload":{
            0:'''
target.Captivated_Source.pop(source_name)
            ''',
            1:'''
if source_name in target.Captivated_Source:
  target.Captivated_Source.pop(source_name)

target.Captivated_Source.update(source_name = 1)

            ''',
            2:'''
target.Captivated_Source.pop(source_name)

target.Captivated_Source.update(source_name = 2)
            ''',
            3:'''
target.Captivated_Source.pop(source_name)

target.Captivated_Source.update(source_name = 3)
            '''
        }
    },

    # I need to add functionality to reset the crit fail threshold after a crit fail. 
    "Confused":{
        "Type": "Mental",
        "Description":"Lack of clear thinking or blurred understanding.\n  \u2022 Removal - Focus (self)/Encourage (ally) check RDC",
        "Stage1": "\u2022 Crit Fail threshold raises by 1 each turn\n\u2022 Resets on Crit Fail",
        "Stage2": "\u2022 Crit Fail threshold raises by 2 each turn\n\u2022 Resets on Crit Fail",
        "Stage3": "\u2022 Crit Fail threshold raises by 3 each turn\n\u2022 Resets on Crit Fail",
         "Interrupt":{
            'Post_Roll':{
              1:'''
if source_roll == 'Critical Fail':
  source.crit_fail_threshold = 1              
              ''',
              2:'''
if source_roll == 'Critical Fail':
  source.crit_fail_threshold = 1              
              ''',
              3:'''
if source_roll == 'Critical Fail':
  source.crit_fail_threshold = 1              
              '''
            }
        },
        "Payload":{
            0:'''
target.Open_Phase.pop("Confused")
            ''',
            1:'''
if "Confused" in target.Open_Phase:
  target.Open_Phase.pop("Confused")
target.Open_Phase.update(Confused = "target.crit_fail_threshold += 1")
            ''',
            2:'''
target.Open_Phase.pop("Confused")

target.Open_Phase.update(Confused = "target.crit_fail_threshold += 2")
            ''',
            3:'''
target.Open_Phase.pop("Confused")

target.Open_Phase.update(Confused = "target.crit_fail_threshold += 3")
            '''
        }
    },

    # Ready to test
    "Frightened":{
        "Type": "Mental",
        "Description":"Antagonized or focussed on a specific enemy\n  \u2022 Removal - Focus (self)/Encourage (ally) check RDC",
        "Stage1": "\u2022 +1 AP on all actions and movement directed to the source of the status",
        "Stage2": "\u2022 +2 AP on all actions and movement directed to the source of the status",
        "Stage3": "\u2022 +3 AP on all actions and movement directed to the source of the status",
         "Interrupt":{
            'Post_Action':{
              1:'''
if target_name in source.Frightened_Source:
  source.AP -= 1              
              ''',
              2:'''
if target_name in source.Frightened_Source:
  source.AP -= 2              
              ''',
              3:'''
if target_name in source.Frightened_Source:
  source.AP -= 3              
              '''
            }
        },
        "Payload":{
            0:'''
target.Frightened_Source.pop(source_name)
            ''',
            1:'''
if source_name in target.Frightened_Source:
  target.Frightened_Source.pop(source_name)

target.Frightened_Source.update(source_name = 1)

            ''',
            2:'''
target.Frightened_Source.pop(source_name)

target.Frightened_Source.update(source_name = 2)
            ''',
            3:'''
target.Frightened_Source.pop(source_name)

target.Frightened_Source.update(source_name = 3)
            '''
        }
    },

    # I need to store the initiative order change
    "Stunned":{
        "Type": "Mental",
        "Description":"A state of inaction or delayed mental composure\n*If initiative position is knocked below the bottom of the round, you lose a turn but gain the first initiative position the next round.*\n\u2022 Removal - Focus (self)/Encourage (ally) check RDC",
        "Stage1": "\u2022 Move back 1 position in the initiative order",
        "Stage2": "\u2022 Move back 3 position in the initiative order",
        "Stage3": "\u2022 Move back 5 position in the initiative order\n\u2022 Gain 1 stage of Prone.",
         "Interrupt":{
            'Pre_Action':{
              1:'''
              
              ''',
              2:'''
              
              ''',
              3:'''
              
              '''
            }
        },
        "Payload":{
            0:"",
            1:"print('1')",
            2:"print('2')",
            3:"print('3')"
        }
    },

    # I need to create an instance of the armor on the character to keep track of durability
    # I also need to keep track of consecutive movement and such
    "Momentum":{
        "Type": "Situational",
        "Description":"Additional force added to attacks\n  \u2022 adds Impact equation\n\u2022 * Gain stages through Positioning and/or charging at enemies in a straight line. \n\u2022 Stage 1= 5 consecutive yards \n\u2022 Stage 2 = 10 consecutive yards \n\u2022 Stage 3 = 20 consecutive yards",
        "Stage1": "\u2022 -1 Crit threshold in the momentum direction\n\u2022 On hit, target Armor -2 Durability",
        "Stage2": "\u2022 -2 Crit threshold in the momentum direction\n\u2022 On hit, target Armor -3 Durability",
        "Stage3": "\u2022 -3 Crit threshold in the momentum direction\n\u2022 On hit, target Armor -5 Durability",
         "Interrupt":{
            'Pre_Action':{
              1:'''
if target.Location == melee_coordinates(source):
  source.crit_threshold -= 1
              ''',
              2:'''
if target.Location == melee_coordinates(source):
  source.crit_threshold -= 2              
              ''',
              3:'''
if target.Location == melee_coordinates(source):
  source.crit_threshold -= 3              
              '''
            }
            },
            "Post_Action":{
                1:'''
if target.Location == melee_coordinates(source):
  if action == 'Weapon Attack':
    weapon = source.Equipment['Main Hand']
    impact(source,target,weapons_dict[weapon]['Type'],'Bludgeoning',False)
source.crit_threshold += 1
              ''',
              2:'''
if target.Location == melee_coordinates(source):
  if action == 'Weapon Attack':
    weapon = source.Equipment['Main Hand']
    impact(source,target,weapons_dict[weapon]['Type'],'Bludgeoning',False)
source.crit_threshold += 2    
              ''',
              3:'''
if target.Location == melee_coordinates(source):
  if action == 'Weapon Attack':
    weapon = source.Equipment['Main Hand']
    impact(source,target,weapons_dict[weapon]['Type'],'Bludgeoning',False)
source.crit_threshold += 3
              '''
        },
        "Payload":{
            0:'''
target.Pre_Action.pop('Momentum')
target.Post_Action.pop('Momentum')            
            ''',
            1:'''
if 'Momentum' in target.Pre_Action:
  target.Pre_Action.pop('Momentum')
  target.Post_Action.pop('Momentum')

target.Pre_Action.update(Momentum = statuses_dict['Momentum']['Interrupt']['Pre_Action'][1])
target.Post_Action.update(Momentum = statuses_dict['Momentum']['Interrupt']['Pre_Action'][1])

            ''',
            2:'''
target.Pre_Action.pop('Momentum')
target.Post_Action.pop('Momentum')

target.Pre_Action.update(Momentum = statuses_dict['Momentum']['Interrupt']['Pre_Action'][1])
target.Post_Action.update(Momentum = statuses_dict['Momentum']['Interrupt']['Pre_Action'][1])

            ''',
            3:'''
target.Pre_Action.pop('Momentum')
target.Post_Action.pop('Momentum')

target.Pre_Action.update(Momentum = statuses_dict['Momentum']['Interrupt']['Pre_Action'][1])
target.Post_Action.update(Momentum = statuses_dict['Momentum']['Interrupt']['Pre_Action'][1])

            '''
        }
    },

    # I need to program out a way to have the removing functions and things so that movement can get rid of this. I might even have to make payloads for removal and put them on the character class
    "Prone":{
        "Type": "Situational",
        "Description":"Degrees of being knocked down or not in a readied combat stance\n\u2022 Removal - using AP to stand. 2 AP per stage",
        "Stage1": "\u2022 -2 on reactions",
        "Stage2": "\u2022 -5 on reactions",
        "Stage3": "\u2022 -10 on reactions",
         "Interrupt":{
            'Pre_Action':{
              1:'''
              
              ''',
              2:'''
              
              ''',
              3:'''
              
              '''
            }
        },
        "Payload":{
            0:"",
            1:"print('1')",
            2:"print('2')",
            3:"print('3')"
        }
    },

    # I need to create the way to remove this, also, maybe change the 
    "Restrained":{
        "Type": "Situational",
        "Description":"Limbs or body that are unable to move freely or are bound by an external force\n\u2022 Removal - Contest your Muscle check against their Grapple check to break free.\n  \u2022 Muscle check is made with a -5 per stage",
        "Stage1": "\u2022 Any restrained limb is considered Crippled 1",
        "Stage2": "\u2022 Any restrained limb is considered Crippled 2",
        "Stage3": "\u2022 Any restrained limb is considered Crippled 3",
         "Interrupt":{
            'Pre_Action':{
              1:'''
              
              ''',
              2:'''
              
              ''',
              3:'''
              
              '''
            }
        },
        "Payload":{
            0:"",
            1:"print('1')",
            2:"print('2')",
            3:"print('3')"
        }
    },

    #add removal and death mechanic when mod reaches -3
    "Suffocating":{
        "Type": "Situational",
        "Description":"Restricted breathing\n *When CON Mod reaches -3 target is Unconscious\n\u2022 Removal - Contest your Muscle check against their Choke check to break free.\n  \u2022 Muscle check is made with a -5 per stage",
        "Stage1": "\u2022 -1 CON Mod per turn",
        "Stage2": "\u2022 -3 CON Mod per turn",
        "Stage3": "\u2022 -5 CON Mod per turn",
         "Interrupt":{
            'Open_Phase':{
              1:'''
drain(target,'CON',5)            
              ''',
              2:'''
drain(target,'CON',10)                 
              ''',
              3:'''
drain(target,'CON',15)                 
              '''
            }
        },
        "Payload":{
            0:'''
target.Open_Phase.pop('Suffocating')            
            ''',
            1:'''
if 'Suffocating' in target.Open_Phase:
  target.Open_Phase.pop('Suffocating')

target.Open_Phase.update(Suffocating = statuses_dict['Suffocating']['Interrupt']['Open_Phase'][1])
            ''',
            2:'''
target.Open_Phase.pop('Suffocating')

target.Open_Phase.update(Suffocating = statuses_dict['Suffocating']['Interrupt']['Open_Phase'][2])
            ''',
            3:'''
target.Open_Phase.pop('Suffocating')

target.Open_Phase.update(Suffocating = statuses_dict['Suffocating']['Interrupt']['Open_Phase'][3])
            '''
        }
    },

    #add removal on attack, and interrupt for roll equation
    "Surprised":{
        "Type": "Situational",
        "Description":"Unaware or unprepared for an attack \n\u2022 Removal - CAll stages lost after the the target is aware of the source of the status",
        "Stage1": "\u2022 Replace the reaction roll with a d20 + Dodge/Defend Respectively",
        "Stage2": "\u2022 Replace the reaction roll with a d20",
        "Stage3": "\u2022 Replace the reaction roll with a d20\n \u2022 Crit fails count as vital 2",
         "Interrupt":{
            'Pre_Action':{
              1:'''
              
              ''',
              2:'''
              
              ''',
              3:'''
              
              '''
            }
        },
        "Payload":{
            0:"",
            1:"print('1')",
            2:"print('2')",
            3:"print('3')"
        }
    }
  }

# positions
positions_dict = {
    "Name":{
    "Description":"string",
    "Stage1": "string",
    "Stage2": "string",
    "Stage3": "string"
    },

    # add an attack direction mechanic 
    "Cover":{
        "Description":"Partly obscured from attacks",
        "Stage1": "\u2022 +5 reactions behind cover",
        "Stage2": "\u2022 +10 reactions behind cover",
        "Stage3": "\u2022 Cannot be targeted by attacks that require sight",
        "Interrupt":{
            'Pre_Action':{
              1:'''
              
              ''',
              2:'''
              
              ''',
              3:'''
              
              '''
            }
        },
        "Payload":{
            0:"",
            1:"print('1')",
            2:"print('2')",
            3:"print('3')"
        }
    },

    #add attack direction
    "Flanked":{
        "Description":"Attacks from the target's peripherals or behind their view",
        "Stage1": "\u2022 Attacks against the target have a -1 Crit threshold",
        "Stage2": "\u2022 Attacks against the target have a -2 Crit threshold",
        "Stage3": "\u2022 Attacks against the target have a -5 Crit threshold",
        "Interrupt":{
            'Pre_Action':{
              1:'''
              
              ''',
              2:'''
              
              ''',
              3:'''
              
              '''
            }
        },
        "Payload":{
            0:"",
            1:"print('1')",
            2:"print('2')",
            3:"print('3')"
        }
        },

        #I don't know, add a hidden from dictionary?
    "Hidden":{
        "Description":"Unable to be seen or unable to be targeted for attacks",
        "Stage1": "\u2022 First attack from hidden gives the target Surprised 1",
        "Stage2": "\u2022 First attack from hidden gives the target Surprised 2",
        "Stage3": "\u2022 First attack from hidden gives the target Surprised 3",
        "Interrupt":{
            'Pre_Action':{
              1:'''
              
              ''',
              2:'''
              
              ''',
              3:'''
              
              '''
            }
        },
        "Payload":{
            0:"",
            1:"print('1')",
            2:"print('2')",
            3:"print('3')"
        }
    },

    #add elevation
    "High Ground":{
        "Description":"Being above the targets and gaining power behind attacks",
        "Stage1": "\u2022 Being above a target giving 1 stage of Momentum",
        "Stage2": "\u2022 Being above a target giving 2 stage of Momentum",
        "Stage3": "\u2022 Being above a target giving 3 stage of Momentum",
        "Interrupt":{
            'Pre_Action':{
              1:'''
              
              ''',
              2:'''
              
              ''',
              3:'''
              
              '''
            }
        },
        "Payload":{
            0:"",
            1:"print('1')",
            2:"print('2')",
            3:"print('3')"
        }
        },

        #I don't fricken know until I add a map
    "Unbalanced":{
        "Description":"Being above the targets and gaining power behind attacks",
        "Stage1": "\u2022 Failed reactions give you a stage of Prone",
        "Stage2": "\u2022 Failed reactions give you a stage of Prone\n\u2022Every Physical Action against you can add a Shove Check for 0 AP",
        "Stage3": "\u2022 Failed reactions give you a stage of Prone\n\u2022Every Physical Action against you can add a Shove Check for 0 AP\n\u2022 Movement provokes a Trip action against you DC 15",
        "Interrupt":{
            'Pre_Action':{
              1:'''
              
              ''',
              2:'''
              
              ''',
              3:'''
              
              '''
            }
        },
        "Payload":{
            0:"",
            1:"print('1')",
            2:"print('2')",
            3:"print('3')"
        }
        }
    }

"""1.   Blinded - can't take into account whether the target is attacking from ranged during the attack action. Pre reaction
2.   Burning - doesn't add in any burning effect to adjacent targets
3.   Crippled - doesn't take into account which arm and it doesn't store them aside from the number action
4.   Deafened - doesn't take into account any flanked direction and therefore doesn't add secondary effect pre roll
5.   fatigued works
6.   Impaled - I need to make a section in the effect action that adds secondary effects. I then need to make a character attribute that stores effect secondary attributes post action/reaction
7.  Captivated - I need to add a function to the action cost function and the turn fuction that changes the AP cost and then store these attributes on the character level pre selection/pre action cost
8.   Confused - I need to add functionality to reset the crit fail threshold after a crit fail. Post roll
9.   Frightened - Same as captivated
10.  Stunned - I need to store the initiative order change
11.   Momentum - I need to create an instance of the armor on the character to keep track of durability, I also need to keep track of consecutive movement and such. Post movement
12.    Prone - I need to program out a way to have the removing functions and things so that movement can get rid of this. I might even have to make payloads for removal and put them on the character class pre movement
13.   Restrained - I need to create the way to remove this, also, maybe change the effect again
14.   Suffocating - add removal and death mechanic when mod reaches -3 add function to class, post open phase
15.   Surprised - add removal on attack, and interrupt for roll equation pre roll
16.   Cover - add an attack direction mechanic pre roll
17.   Flanked - Same as Cover pre roll
18.   Hidden - I don't know, add a hidden from dictionary? hidden dictionary
19.   High Ground - add elevation
20.   Unbalanced - Wait till map post move

character - grid position, character body, armor

function - secondary effect: deafened and impaled and , removal, 

update - attack: ranged, turn: flanked, action_cost and turn : ap change
"""

# Damage Types

damage_types_dict = {
    "Name":
    {
        "Type": "string",
        "Description": "string",
        "Mechanics": "string",
        "Effect": "string",
        "Statuses": 
        [
            "string",
            "string"
        ]
    },
    "Piercing":
    {
        "Type": "Physical",
        "Description": "A physical attack meant to impale the point of a weapon in a target",
        "Mechanics": "\u2022 -1 Crit threshold vs Vitals\n\u2022 Can choose to damage a target or give the target a stage of:\n     \u2022 Impaled\n     \u2022 Blinded",
        "Effect": "Crit Threshold -1",
        "Statuses": 
        [
            "Blinded",
            "Impaled"
        ]
    },
    "Slashing":
    {
        "Type": "Physical",
        "Description": "A physical attack that sweeps a bladed edge against a target",
        "Mechanics": "\u2022 Can Dismember a limb that is Crippled 3\n\u2022 Can choose to damage a target or give the target a stage of:\n     \u2022 Bleeding\n     \u2022 Blinded\n     \u2022 Crippled",
        "Effect": "if target_crippled_stage == 3: ",
        "Statuses": 
        [
            "Damage",
            "Bleeding",
            "Blinded",
            "Crippled"
        ]
    },
    "Bludgeoning":
    {
        "Type": "Physical",
        "Description": "A physical attack that impacts a blunt weapons against a target",
        "Mechanics": "\u2022 Double Damage against armor\n\u2022 Can choose to damage a target or give the target a stage of:\n     \u2022 Fatigued\n     \u2022 Deafened\n     \u2022 Crippled\n     \u2022 Confused\n     \u2022 Stunned",
        "Effect": "target_armor_durability = - 2 ",
        "Statuses": 
        [
            "Damage",
            "Fatigued",
            "Deafened",
            "Crippled",
            "Confused",
            "Stunned"
        ]
    },
    "Fire":
    {
        "Type": "Elemental",
        "Description": "A fire damage that gives a target stages of Burning",
        "Mechanics": "\u2022 Can be boosted by Flammable materials\n\u2022 Can choose to damage a target or give the target a stage of:\n     \u2022 Burning",
        "Effect": "",
        "Statuses": 
        [
            "Damage",
            "Burning"
        ]
    },
    "Freezing":
    {
        "Type": "Elemental",
        "Description": "A cold damage that can damage and give a target stages of Frozen",
        "Mechanics": "\u2022 Can be boosted by Freezable materials\n\u2022 Can choose to damage a target or give the target a stage of:\n     \u2022 Frozen",
        "Effect": "",
        "Statuses": 
        [
            "Damage",
            "Frozen"
        ]
    },
    "Lightning":
    {
        "Type": "Elemental",
        "Description": "An electric damage that damages and turn a target into an Elemental Weapon",
        "Mechanics": "\u2022 Can be boosted by Conductive materials",
        "Effect": "",
        "Statuses": 
        [
            "Damage"
        ]
    },
    "Acid":
    {
        "Type": "Arcane",
        "Description": "A corrosive attack that burns and dissolves organic matter",
        "Mechanics": "\u2022 Only effects Animal and Vegetable materials\n\u2022 Can choose to damage a target or give the target a stage of:\n     \u2022 Burning",
        "Effect": "",
        "Statuses": 
        [
            "Damage",
            "Burning"
        ]
    },
    "Chaos":
    {
        "Type": "Arcane",
        "Description": "A corrosive attack that burns and dissolves organic matter",
        "Mechanics": "",
        "Effect": "",
        "Statuses": 
        [
            "Damage",
            "Burning"
        ]
    },    
    "Necrotic":
    {
        "Type": "Arcane",
        "Description": "Arcane energy that decreases the very life force of a target",
        "Mechanics": "\u2022 Does not effect non living targets",
        "Effect": "",
        "Statuses": 
        [
            "Damage"
        ]
    }
}

"""# Functions"""

def mods(attribute):
    mod = (attribute // 5) - 2
    return mod

#Dice Roller

def roll_dice(high,fail,crit):
  total = random.randint(1,high)
  if total <= fail:
    print("You rolled a " + str(total) + " which is a Critical Fail")
    return "Critical Fail"
  elif total >= crit:
    print("You rolled a " + str(total) + " which is a Critical!")
    return "Critical"
  else:
    print("Roll = " + str(total))
    return total


def temp_bonus(source):
  source = make_class(source)

  bonus = source.temp_bonus

  print(source.Name + ", you use your temp bonus of: " + str(bonus))
  temp_bonus = 0

  return bonus

def make_string(target):
  if type(target) == str:
    return target
  else:
    return target.Name

def make_class(target):
  if type(target) == str:
    return eval(target)
  else:
    return target

def break_stamina(target,*amount):
  target = make_class(target)
  target_name = make_string(target)

  if amount:
    amount = int(amount[0])
  else:
    amount = 1
  stamina = target.Stamina

  stamina = target.Stamina

  injuries = ["Bleeding", "Blinded", "Crippled", "Fatigued", "Confused", "Stunned"]

  injury = injuries[roll_dice(6,-1,7)] - 1

  while amount > 0:
    print("You broke your " + stamina + " stamina. Take an injury")
    target.HP[stamina] = 0
    if stamina == "Prime":
      target.Stamina = "Wounded"
      target.Statuses[injury] += 1
      print("You took a stage of: " + injury + " as an injury")
    elif stamina == "Wounded":
      target.Stamina = "Bloodied"
      target.Statuses[injury] += 2
      print("You took two stages of: " + injury + " as an injury")
    else:
      target.Stamina = "Bleeding Out"
      target.Statuses[injury] += 3
      print("You took 3 stages of: " + injury + " as an injury. \nYou lose all strength and begin " + target.Stamina + "\n Roll Death Saving throws")

    amount -= 1

def equip(source,item,slot):
  source = make_class(source)
  if slot == "Main Hand":
    source.Equipment[slot] = weapons_dict[item]

    # if len(weapons_dict[item]["Features"]) > 0:
    for i in weapons_dict[item]["Features"]:
      exec(features_dict[i]["Equip"])
      print(i)
  elif slot == "Armor":
    source.Equipment[slot] = armors_dict[item]

    # if len(armors_dict[item]["Features"]) > 0:
    for i in armors_dict[item]["Features"]:
      exec(armors_dict[i]["Equip"])
      print(i)

def equip_all(source):
  source = make_class(source)

  for slot in source.Equipment:
    if source.Equipment[slot] != '':
      equip(source,source.Equipment[slot],slot)

def unequip(source,slot):
  source = make_class(source)
  item = source.Equipment[slot]["Name"]
  if slot == "Main Hand":
    # if len(weapons_dict[item]["Features"]) > 0:
    for i in weapons_dict[item]["Features"]:
      exec(features_dict[i]["Unequip"])
      print(i)
  elif slot == "Armor":
    source.Equipment[slot] = armors_dict[item]

    # if len(armors_dict[item]["Features"]) > 0:
    for i in weapons_dict[item]["Features"]:
      exec(features_dict[i]["Unequip"])
      print(i)
  
  source.Equipment[slot] = None

def damage(target,*amount):
  target = make_class(target)
  target_name = make_string(target)
  armor = target.Equipment["Armor"]
  if amount:
    amount = int(amount[0])
  else:
    amount = 1
  stamina = target.Stamina

  print(target_name + ", you have " + str(target.HP["Total"]) + " HP and you took " + str(amount) + " damage")
  while amount > 0:
    print(target_name + " HP breakdown:\n Total HP = " + str(target.HP["Total"]) + "\nPrime HP = " + str(target.HP["Prime"]) + "\nWounded HP = " + str(target.HP["Wounded"]) + "\nBloodied HP = " + str(target.HP["Bloodied"]))
    
    if target.HP[stamina] == 0:
      break_stamina(target)
      if target.Stamina == "Bleeding Out":
        if type(target) == Creature:
          target.Hostile = False
          print(target_name + ", you are Dead")
        else:
          target.Death_Fails += 1
          print(target_name + ", you took damage while bleeding out resulting in a failed death saving throw")
        break
    
    stamina = target.Stamina
    target.HP[stamina] -= 1
    target.HP["Total"] -= 1
    target.Equipment["Armor"][armor]["Durability"] -= 1
    amount -= 1
          
    print("You now have " + str(target.HP["Total"]) + " HP")

def drain(target,attribute,amount):
  target = make_class(target)

  while amount > 0:
    if target.Attributes[attribute] == 0:
      status(target,'Unconscious',1)
    target.Attributes[attribute] -= 1
    
    amount -= 1

def distance(source,target):
  source = make_class(source)
  target = make_class(target)

  source_location = source.Location
  target_location = target.Location 

  x_distance = abs(source_location['x'] - target_location['x'])
  y_distance = abs(source_location['y'] - target_location['y'])
  z_distance = abs(source_location['z'] - target_location['z'])

  distance = [x_distance,y_distance,z_distance]

  distance.sort()
  return distance[-1]

def convert_direction(direction):
    if direction == 0:
      return "North"
    elif direction == 1:
      return 'North East'
    elif direction == 2:
      return 'East'
    elif direction == 3:
      return 'South East'
    elif direction == 4:
      return 'South'
    elif direction == 5:
      return 'South West'
    elif direction == 6:
      return 'West'
    else:
      return 'North West'

def melee_coordinates(target):
  target = make_class(target)

  target_coordinates = target.Location
  attack_coordinates = target_coordinates
  if target.Direction == 0:
    attack_coordinates['y'] += 1
  elif target.Direction == 1:
    attack_coordinates['x'] += 1
    attack_coordinates['y'] += 1
  elif target.Direction == 2:
    attack_coordinates['x'] += 1
  elif target.Direction == 3:
    attack_coordinates['x'] += 1
    attack_coordinates['y'] -= 1
  elif target.Direction == 4:
    attack_coordinates['y'] -= 1
  elif target.Direction == 5:
    attack_coordinates['x'] -= 1
    attack_coordinates['y'] -= 1
  elif target.Direction == 6:
    attack_coordinates['x'] -= 1
  else:
    attack_coordinates['x'] -= 1
    attack_coordinates['y'] += 1

  return attack_coordinates

# I need to add a second impact once I add materials
def force_move(target,amount,direction):
  print(target.Name + ", you are moved " + str(amount) + " in the " + convert_direction(direction) + " direction.\nYour starting coordinates are ")
  print(target.Location)
  while amount > 0:
    if direction == 0:
      target.Location['y'] += 1
    elif direction == 1:
      target.Location['x'] += 1
      target.Location['y'] += 1
    elif direction == 2:
      target.Location['x'] += 1
    elif direction == 3:
      target.Location['x'] += 1
      target.Location['y'] -= 1
    elif direction == 4:
      target.Location['y'] -= 1
    elif direction == 5:
      target.Location['x'] -= 1
      target.Location['y'] -= 1
    elif direction == 6:
      target.Location['x'] -= 1
    else:
      target.Location['x'] -= 1
      target.Location['y'] += 1
    amount -= 1

  print("Your ending coordinates are: ")
  print(target.Location)

def impact(source,target,source_dtype,target_dtype,collision):
  def impact_result(target,amount,direction,dtype):
    capacity = amount // 2
    if dtype == 'Bludgeoning':
      if capacity > 0:
        damage(target,capacity)
        status(target,'Prone',capacity)
      print(target.Name + ", the impact pushes you " + str(amount) + " yards away in the " + convert_direction(direction) + "\nYou take" + str(capacity) + " damage and\n" + str(capacity) + " stages of prone")
      force_move(target,amount,direction)
    elif dtype == 'Piercing':
      print(target.Name + ", the impact impales you " + str(capacity) + " stages")
      status(target,'Impaled',capacity)
    else:
      print(target.Name + ", the impact gives you " + str(capacity) + " stages of bleeding")
      status(target,'Impaled',capacity)




  source = make_class(source)
  target = make_class(target)

  source_momentum = source.Statuses['Momentum']
  target_momentum = target.Statuses['Momentum']

  
  angle = abs(source.Direction - target.Direction)
  if angle == 4:   
    source_force = source.Weight * (1 + source_momentum)
    target_force = target.Weight * (1 + target_momentum)

  elif angle == 0:
    source_momentum = source_momentum - target_momentum
    if source_momentum < 0:
      source_momentum = 0

    source_force = source.Weight * (1 + source_momentum)
    target_force = target.Weight
  
  else:
    source_force = source.Weight * (1 + source_momentum)
    target_force = target.Weight

  print(source.Name + ", your total force units are: \n" + str(source_force))
  print(target.Name + ", your total force units are: \n" + str(target_force))

  if collision == True:
    if source_force > target_force:
      amount = source_force - target_force
      impact_result(target,amount,target.Direction,target_dtype)
    elif target_force > source_force:
      amount = source_force - target_force
      impact_result(source,amount,source.Direction,source_dtype)
    else:
      amount = source_force
      impact_result(target,amount,target.Direction,target_dtype)
      impact_result(source,amount,source.Direction,source_dtype)
  else:
    if source_force > target_force:
      amount = source_force - target_force
      impact_result(target,amount,target.Direction,target_dtype)
    else:
      print("The attack didn't have enough force for an impact")

# Contest function

#Player starts turn, 
# prompt player with action
# player selects action 
# prompt player with description and get confirmation
# if the player doesn't confirm, prompt again
# player selects target, rolls and adds modifiers, the target then selects a reaction (unless predefined in action) and rolls + modifiers. (prompt GM for approval) If Player > target, apply payload, else no effect. Deduct AP
# else if the action is a scale - roll and add modifiers, then prompt GM for approval, then apply the effect based on the range. Deduct AP
# else if the action is a DC, roll and add modifiers, then prompt GM for approval, if yes, apply effect. Deduct AP

def contest(source,action,target):
  source = make_class(source)
  source_name = make_string(source)

  source_stat = mods(source.Attributes[str(actions_dict[action]["Stat"])])
  source_skill = source.Skills[actions_dict[action]["Skill"]]
  source_mod = source.misc_bonus
  source_crit = source.crit_threshold
  source_crit_fail = source.crit_fail_threshold

  target = make_class(target)
  target_name = make_string(target)  
  target_crit = target.crit_threshold
  target_crit_fail = target.crit_fail_threshold

  # add Pre_Roll effects if any
  if len(source.Pre_Roll) > 0:
    interrupt(source, "Pre_Roll") 

  source_dice = roll_dice(20,source_crit_fail,source_crit)
  
  # add Post_Roll effects if any
  if len(source.Post_Roll) > 0:
    interrupt(source, "Post_Roll")

    

    #roll source actions
  if source_dice == "Critical" or "Critical Fail":
    source_roll = source_dice
  else:
    source_roll = source_dice + source_stat + source_skill + source_mod
  print("After all bonuses, your total is " + str(source_roll))

  source_mod = 0

  reaction = actions_dict[action]["Reaction"]
  print(target_name + ", Roll a " + reaction + " check as a reaction.")

  if reaction == "Muscle" or "Wrestle" or "Brawl" or "Jump":
    reaction_stat = "STR"
  elif reaction == "Coordination" or "Finesse" or "Sleight" or "Stealth":
    reaction_stat = "DEX"
  elif reaction == "Endurance" or "Concentration" or "Vitality":
    reaction_stat == "CON"
  elif reaction == "Academic" or "Arcana" or "Culture" or "Investigation" or "Nature":
    reaction_stat = "INT"
  elif reaction == "Insight" or "Interaction" or "Medicine" or "Perception" or "Survival":
    reaction_stat = "WIS"
  elif reaction == "Aggressive" or "Suave" or "Diplomatic" or "Sincere":
    reaction_stat = "CHA"
  else:
    reaction_stat = input("What is the stat for your reaction: STR; DEX; CON; INT; WIS; CHA")
  
  target_stat = mods(target.Attributes[reaction_stat])
  target_skill = target.Skills[reaction]
  target_dice = roll_dice(20,target_crit_fail,target_crit)

  if target_dice == "Critical" or "Critical Fail":
    target_roll = target_dice
  else:
    target_roll = target_dice + target_stat + target_skill + eval(target + ".misc_bonus")
  print(target_name + "'s " + reaction + " is total is " + str(target_roll))
  
  if source_roll == target_roll:
    print("You both tied and cancel each other out")
    result = "Tie"
  elif source_roll == "Critical":
    print("You rolled a critical success!")
    result = "Critical"
  elif source_roll == "Critical Fail":
    print("You rolled a critical fail")
    result = "Critical Fail"
  elif target_roll == "Critical":
    print("Your target rolled a critical success, you fail")
    result = "Critical Fail"
  elif target_roll == "Critical Fail":
    print("Your target rolled a critical fail, you succeed")
    result = "Critical"
  elif source_roll > target_roll:
    print("You succeed!")
    result = "Success"
  else:
    result = "Fail"
    print("Sorry, you failed")
  return result

# Special action function for actions that trigger a target's choice of standard reactions

#Player starts turn, 
# prompt player with action
# player selects action 
# prompt player with description and get confirmation
# if the player doesn't confirm, prompt again
# if the action is a contest, player selects target, rolls and adds modifiers, the target then selects a reaction (unless predefined in action) and rolls + modifiers. (prompt GM for approval) If Player > target, apply payload, else no effect. Deduct AP
# else if the action is a scale - roll and add modifiers, then prompt GM for approval, then apply the effect based on the range. Deduct AP
# else if the action is a DC, roll and add modifiers, then prompt GM for approval, if yes, apply effect. Deduct AP

def attack(source,action,target,reaction):

  #set up sourse variables

  source = make_class(source)
  source_name = make_string(source)

  source_stat = mods(source.Attributes[str(actions_dict[action]["Stat"])])
  source_skill = source.Skills[str(actions_dict[action]["Skill"])]
  source_mod = source.misc_bonus 
  source_crit = source.crit_threshold
  source_crit_fail = source.crit_fail_threshold

  source_weapon = source.Equipment["Main Hand"]
  


  #set up target Variables
  
  target = make_class(target)
  target_name = make_string(target)  
  target_crit = target.crit_threshold
  target_crit_fail = target.crit_fail_threshold
  target_armor = target.Equipment["Armor"]


  # add Pre_Roll effects if any
  if len(source.Pre_Roll) > 0:
    interrupt(source, "Pre_Roll") 

  source_dice = roll_dice(20,source_crit_fail,source_crit)
  
  # add Post_Roll effects if any
  if len(source.Post_Roll) > 0:
    interrupt(source, "Post_Roll")


    #roll source actions
  if type(source_dice) == str:
    source_roll = source_dice
  else:
    source_roll = source_dice + source_stat + source_skill + source_mod + temp_bonus(source)
  print("After all bonuses, your total is " + str(source_roll))

  source_mod = 0

  #get target reaction
  print(target_name + " chose to react with " + reaction)


  print(target_name + ", Roll a " + reaction + " check as a reaction.")

  # Roll reaction for target 
  target_stat = mods(target.Attributes[actions_dict[reaction]["Stat"]])
  target_skill = target.Skills[actions_dict[reaction]["Skill"]]

  if actions_dict[reaction]["Dice_Roll"] == "d6":
    target_dice = roll_dice(6,0,target_crit)
    if reaction == "Block":
      target_roll = target_dice + armors_dict[target_armor]["Defend"] + math.floor(armors_dict[target_armor]["Block_Bonus"] * (target_stat + target_skill))
      print("The targets' " + reaction + " roll is " + str(target_dice) + " dice roll + " + str(armors_dict[target_armor]["Defend"]) + " armor base + (" + str(math.floor(armors_dict[target_armor]["Block_Bonus"])) + " modifier of " + str(target_stat + target_skill) + " skill bonus) \nfor a total of \n" + str(target_roll))
    else:
      target_roll = target_dice + armors_dict[target_armor]["Agility"] + math.floor(armors_dict[target_armor]["Dodge_Bonus"] * (target_stat + target_skill))
      print("The targets' " + reaction + " roll is " + str(target_dice) + " dice roll + " + str(armors_dict[target_armor]["Agility"]) + " armor base + (" + str(armors_dict[target_armor]["Dodge_Bonus"]) + " modifier of " + str(target_stat + target_skill) + " skill bonus) \nfor a total of \n" + str(target_roll))
  else:
    target_dice = roll_dice(20,target_crit_fail,target_crit)
    if type(target_dice) == str:
      target_roll = target_dice
    else:
      target_roll = target_dice + target_stat + target_skill
    print("The targets' " + reaction + " is total is " + str(target_roll))



  if source_roll == target_roll:
    print("You both tied and cancel each other out")
  elif source_roll == "Critical":
    print("You rolled a critical success!")
    result = "Critical"
  elif source_roll == "Critical Fail":
    print("You rolled a critical fail")
    result = "Critical Fail"
  elif target_roll == "Critical":
    print("Your target rolled a critical success, you fail")
    result = "Critical Fail"
  elif target_roll == "Critical Fail":
    print("Your target rolled a critical fail, you succeed")
    result = "Critical"
  elif source_roll > target_roll:
    print("You succeed!")
    result = "Success"
  else:
    result = "Fail"
    print("Sorry, you failed")
  return result

def range_action(source,action):

  source = make_class(source)
  source_name = make_string(source)

  source_stat = mods(source.Attributes[str(actions_dict[action]["Stat"])])
  source_skill = source.Skill[str(actions_dict[action]["Skill"])]
  source_mod = source.misc_bonus
  source_crit = source.crit_threshold
  source_crit_fail = source.crit_fail_threshold
  

  # add Pre_Roll effects if any
  if len(source.Pre_Roll) > 0:
    interrupt(source, "Pre_Roll") 

  source_dice = roll_dice(20,source_crit_fail,source_crit)
  
  # add Post_Roll effects if any
  if len(source.Post_Roll) > 0:
    interrupt(source, "Post_Roll")


    #roll source actions
  if type(source_dice) == str:
    source_roll = source_dice
  else:
    source_roll = source_dice + source_stat + source_skill + source_mod
  print("After all bonuses, your total is " + str(source_roll))

  source_mod = 0

  return source_roll

def dc_action(source,action):
  source = make_class(source)
  source_name = make_string(source)

  source_stat = mods(source.Attributes[str(actions_dict[action]["Stat"])])
  source_skill = source.Skill[str(actions_dict[action]["Skill"])]
  source_mod = source.misc_bonus
  source_crit = source.crit_threshold
  source_crit_fail = source.crit_fail_threshold

  # add Pre_Roll effects if any
  if len(source.Pre_Roll) > 0:
    interrupt(source, "Pre_Roll")

  source_dice = roll_dice(20,source_crit_fail,source_crit)
  
  # add Post_Roll effects if any
  if len(source.Post_Roll) > 0:
    interrupt(source, "Post_Roll")


    #roll source actions
  if type(source_dice) == str:
    source_roll = source_dice
  else:
    source_roll = source_dice + source_stat + source_skill + source_mod
  print("After all bonuses, your total is " + str(source_roll))

  source_mod = 0


  if source_roll == "Critical":
    print("You rolled a critical success!")
    result = "Critical"
  elif source_roll == "Critical Fail":
    print("You rolled a critical fail")
    result = "Critical Fail"
  else:
    result = input("GM, the player rolled a " + str(source_roll) + "\nIs that a Success or a Fail?")

  return result

# move action

def move(source):
  #get source
  source = make_class(source)
  source_name = make_string(source)

  # get source location
  start_location = source.Location
  current_location = start_location

  print("Your starting location is: \n" + str(current_location))

  accepted = False

  while accepted == False:
    #get each aspect of the destination location
    print("Where do you want to go?")
    x = input("What is the x coordinate?")
    y = input("What is the y coordinate?")
    z = input("What is the z coordinate?")
    destination = {
        "x":int(x),
        "y":int(y),
        "z":int(z)
        }

    #get the length of each coordinate change
    len_x = abs(current_location["x"] - destination['x'])
    len_y = abs(current_location["y"] - destination['y'])
    len_z = abs(current_location['z'] - destination['z'])
    

    # get the distance to the objective 
    if len_x >= len_y:
      distance = len_x
    else:
      distance = len_y

    # if the distance is greater than the source resources restart the loop
    if distance > source.MP:
      if distance <= source.AP + source.MP:
        confirm = input(source_name + ", the distance is greater than your existing MP and you will have to spend AP to travel the rest of the way. Do you still want to travel here")
        if confirm == "yes":
          print("Perfect, your destination is " + str(distance) + " yards away")
          accepted = True
        else:
          print("Please select another location")
          accepted = False
      else:
        print(source_name + ", sorry, your destination is beyond your remaining. Please select another destination")
        accepted = False
    else:
      print("Perfect, your destination is " + str(distance) + " yards away")
      accepted = True
    

  # now outside the loop, create another loop for each yard you move. It should do the following: find the shortest path between two points, determine look direction. 
  while distance > 0:
    len_x = abs(current_location["x"] - destination['x'])
    len_y = abs(current_location["y"] - destination['y'])
    len_z = abs(current_location['z'] - destination['z'])
    if len_x > len_y:
      #moving left/West
      if current_location['x'] > destination['x']:
        source.Look_Direction = 6
        current_location['x'] -= 1
        source.Location = current_location
        print("You move 1 yard West")
      #moving righ/East
      else:
        source.Look_Direction = 2
        current_location['x'] += 1
        source.Location = current_location
        print("You move 1 yard East")

    elif len_x < len_y:
      #moving down/South
      if current_location['y'] > destination['y']:
        source.Look_Direction = 4
        current_location['y'] -= 1
        source.Location = current_location
        print("You move 1 yard South")
      #moving up/North
      else:
        source.Look_Direction = 0
        current_location['y'] += 1
        source.Location = current_location
        print("You move 1 yard North")

    else:
      #moving up+right/North East
      if current_location['y'] < destination['y'] and current_location['x'] < destination['x']:
        source.Look_Direction = 1
        current_location['x'] += 1
        current_location['y'] += 1
        source.Location = current_location
        print("You move 1 yard North East")

      #moving down+right/South East
      elif current_location['y'] > destination['y'] and current_location['x'] < destination['x']:
        source.Look_Direction = 3
        current_location['x'] += 1
        current_location['y'] -= 1
        source.Location = current_location
        print("You move 1 yard South East")

      #moving down+left/South West
      elif current_location['y'] > destination['y'] and current_location['x'] > destination['x']:
        source.Look_Direction = 5
        current_location['x'] -= 1
        current_location['y'] -= 1
        source.Location = current_location
        print("You move 1 yard South West")

      #moving up+left/North West
      else:
        source.Look_Direction = 7
        current_location['x'] -= 1
        current_location['y'] += 1
        source.Location = current_location
        print("You move 1 yard North West")
      
    distance -= 1

  print("Your final coordinates are:\n" + str(source.Location))

def weapon_attack(source):

  source = make_class(source)
  weapon = source.Equipment["Main Hand"]

  damage_type = weapons_dict[weapon]["Type"]

  print("What base effect do you want to do?")
  for i in damage_types_dict[damage_type]:
    print(i)

  base_effect = input("Select your Base effect?")

  if len(weapons_dict[weapon]["Techniques"]) > 1:
    print("Here are your available techniques")
    for i in weapons_dict[weapon]["Techniques"]:
      print(i)
    if "Heavy" in weapons_dict[weapon]["Features"]:
      technique1 = input("What is the first technique you want to use?")
      level1 = weapons_dict[weapon]["Techniques"][technique1]
      technique2 = input("What is the second technique you want to use?")
      level2 = weapons_dict[weapon]["Techniques"][technique2]
      technique = {technique1:level1,technique2:level2}
    else:
      technique = input("Which technique do you want to do?")
      level = weapons_dict[weapon]["Techniques"][technique]
  else:
    for k,v in weapons_dict[weapon]["Techniques"]:
      technique = k
      level = v
      technique = {technique:level}

  if "Distance" in technique:
    level = technique["Distance"]
    exec(techniques_dict["Distance"][level]["Payload"])
  elif "Pin Point" in technique:
    level = technique["Pin Point"]
    exec(techniques_dict["Pin Point"][level]["Payload"])



  options = {
      "Weapon":weapon,
      "Base": base_effect,
      "Technique": technique,
  }
  source.Attack_Options = options

def action_cost(source,action):
  source = make_class(source)

  if actions_dict[action]["Speed"] == "~":
    weapon = source.Equipment["Main Hand"]
    action_cost = weapons_dict[weapon]["AP"]
  else:
    action_cost = actions_dict[action]["Speed"]
  return action_cost

def stamina(source):
  source_stamina = source.Stamina
  source.HP[source_stamina] = eval(str(source.Name) + "." + str(source_stamina))
  source_AP = source.Max_AP
  source_RP = source.Max_RP
  source_MP = source.Max_MP
  print(str(source.Name) + ":\nCurrent HP = " + str(source.HP["Prime"] + source.HP["Wounded"] + source.HP["Bloodied"]) + "\nCurrent Stamina = " + source_stamina + "\nAP = " + str(source_AP) + "\nRP = " + str(source_RP) + "\nMP = " + str(source_MP))

# effect function

def effect(source,target,action,result):
  source = make_class(source)
  source_name = make_string(source)
  target = make_class(target)
  target_name = make_string(target)
  
  
  if result == "Fail":
    print("Sorry you Suck")
  elif result == 'Critical Fail':
    print("You really suck bad")
  elif result == "Critical":
    if actions_dict[action]["Action_Type"] == "Range":
      result = 30
      exec(actions_dict[action]["Payload"])
    elif action == "Weapon Attack":
      amount = 0
      options = source.Attack_Options
      amount == weapons_dict[options["Weapon"]]["Crit Damage"]
    else:
      exec(actions_dict[action]["Payload"])
      exec(actions_dict[action]["Payload"])
  else:
    amount = 1
    exec(actions_dict[action]["Payload"])

"""successfull actions:
Disarm,
Choke,
Grapple,
Strike,
Shove,
Leap,
Lunge,
Hide,
Brace,
Concentrate,
Focus,
Charge Power,
Recover,
Tactics,
Enemy Status,
Bandage,
Aim,
Find Vitals,
Distract,
Pacify

reactions:
Dive,
Dodge,
Parry,
Riposte,
Trip,
Block

failed actions:
Steal,
Encourage

incomplete actions:
Weapon Attack,
Throw,
Tackle,
Climb,
Feint,
Enemy History,
Arcana,
Search,
Battlefield,
Coordinated Attack,
Improvise
"""

def status(target,status,stage,*source):
  target = make_class(target)
  target_name = make_string(target)
  current_stage = target.Statuses[status]

  
  if source:
    sources = []
    for item in source:
      sources.append(item)

    source = str(sources[0])
    source = make_class(source)
    source_name = make_string(source)
    print(source)
    print(source_name)
    

  print(target_name + ", your " + status + " status is currently at stage: " + str(current_stage) + "\n It is now being adjusted by " + str(stage))
  if stage > 0:
    while stage > 0:
      if current_stage == 4:
        # change this to vital attack?
        print(target_name + ", your " + status + " is maxed and is a permanent injury. You can't take any more stages and instead, you take a vital 1 attack")
        break_stamina(target)
      elif current_stage == 3:          
        if statuses_dict[status]["Type"] == "Physical":   
          print(target_name + ", your " + status + " was already at stage 3. This status now becomes a permanent injury")
          target.Statuses[status] += 1
          exec(statuses_dict[status]["Payload"][target.Statuses[status]])
        else:
          print(target_name + ", your " + status + " is maxed and you can't take any more stages.")
      else:
        target.Statuses[status] += 1
        exec(statuses_dict[status]["Payload"][target.Statuses[status]])

      stage -= 1
  else:
    while stage < 0:
      if current_stage == 4:
        print(target_name + ", your " + status + " is maxed and is a permanent injury. You can't heal any stages without magical assitance or rest")
      elif statuses_dict[status]["Type"] == "Physical" and current_stage == 1:
        print(target_name + ", your " + status + " is a physical status. You can't heal past stage 1 without magical assitance or rest")
      else:
        target.Statuses[status] -= 1
        exec(statuses_dict[status]["Payload"][target.Statuses[status]])
      
      stage += 1

def open_phase(target):
  target = make_class(target)
  target_name = make_string(target)

  for k,v in target.Open_Phase.items():
    print(k)
    exec(v)

def interrupt(target,phase):
  target = make_class(target)
  target_name = make_string(target)
  phase = eval(target_name + "." + phase)

  for k,v in phase.items():
    print(k)
    exec(v)

def turn(player):
  # source = eval(str(player))
  source = make_class(player)
  source_name = make_string(player)

  print(source_name + ", Its your turn!\n\nYour stamina kicks in and regenerates your HP, AP, RP, and MP")
  stamina(source)

  open_phase(source)
  
  #add Post_Open_Phase effects if any
  if len(source.Post_Open_Phase) > 0:
    interrupt(source,"Post_Open_Phase")
  
  source_AP = source.AP
  source_MP = source.MP

  while source_AP > 0:
    action = input("What would you like to do?")
    
    if action == "Weapon Attack":
      action_AP = weapons_dict[source.Equipment['Main Hand']]["AP"]
    else:
      action_AP = actions_dict[action]["Speed"]
    print(actions_dict[action]["Description"])
    if int(action_AP) > source_AP:
      action = input("Sorry, you don't have enough AP for that action\nWhat else would you like to do")

    

    print("You have " + str(source_AP) + " left and the " + action + " action costs " + str(action_AP) + " AP")
    confirmation = input("Do you wish to proceed?")

    if confirmation == "yes":
      # add Pre_Action effects if any 
      if action == "Weapon Attack":
        weapon_attack(source)
        if len(source.Pre_Action) > 0:
          interrupt(source,"Pre_Action")
      else:
        if len(source.Pre_Action) > 0:
            interrupt(source,"Pre_Action")

        if actions_dict[action]["Action_Type"] == "Attack":
          target_name = input("Who would you like to target?")
          target = make_class(target_name)  
          reaction = input(target_name + ", " + source_name + " is targeting you with a " + action + " action. How do you react?")
          if len(target.Pre_Reaction) > 0:
            interrupt(target, "Pre_Reaction")
          result = attack(source, action, target, reaction)
          if len(target.Post_Reaction) > 0:
            interrupt(target, "Post_Reaction")
        elif actions_dict[action]["Action_Type"] == "Range":
          target = source
          result = range_action(source, action)
        elif actions_dict[action]["Action_Type"] == "Contest":
          target = input("Who would you like to target?")
          result = contest(source, action, target)
        elif actions_dict[action]["Action_Type"] == "DC":
          target = input("Who would you like to target?")
          result = dc_action(source,action)

      source_AP -= int(action_cost(source, action))
  
    else:
        print("I'll cancel that for you!")

    print("The result of you " + action + " action is " + str(result))
    
    effect(source,target,action,result)

    # add Post_Action effects if any
    if len(source.Post_Action) > 0:
      interrupt(source,"Post_Action")

    print("You still have " + str(source_AP) + " AP left.")


  print("You are out of AP and your turn is done\n\n")

def round_mechanics(*initiative_list):
  print("Round Mechanics aren't done yet")

def combat_round(initiative):
  round_mechanics()
  hostile = True
  turn_count = 1
  while hostile == True:
    print("\n\nIt is the top of round " + str(turn_count) + ".\n" + initiative[0] + ", you are up first!\n\n")
    for combatant in initiative:
      print("Its your turn " + combatant)
      turn(combatant)
    turn_count += 1

def combat_encounter(*combatants):
  initiative = []
  initiative_order = []
  for i in combatants:
    combat_order = {
        "name": i.Name,
        "initiative":roll_dice(20,0,21)
        }
    initiative.append(combat_order)

  print(initiative)

  initiative_list = sorted(initiative, key=lambda x: x['initiative'], reverse=True)

  for i in initiative_list:
    print(i["name"], i["initiative"])
    initiative_order.append(i["name"])
    
  for i in initiative_order:
    print(i)

  hostile = True
  while hostile == True:
    combat_round(initiative_order)
  print("You all hostiles have been subdued or eliminated")

"""# Trials

This is where I am trying out sections of my code
"""

#creating stats  

Dougey = PC("Dougey", "Brute", "Human", "Blue", "Skin_Tone", "Hair_Color", 1, 4, "Trademarks", 25, 15, 20, 5, 10, 15, 2, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 2, 0, 0, 1, 2, 2, 1, 0, 1, 0, 0, 0, 2, 2, 2, "Offensive_Ability", "Defensive_Ability", "Movement_Ability", "Special_Ability", "Long Sword", "Off_Hand", "Utility", "Leather Armor", "Combat_Special_Move", "Backpack", "Gold", "Rations", "Kits", "Adventuring_Special_Moves", "Value_Self", "Value_Others", "Value_Society", "Mission", "Interests", "Talents", "Quirks", "Fears", "Family", "Friends", "Professional", "Nemesis", "Factions", "Home", "Profession", "Skill", "Race_Bonus", "Story", "Roleplaying_Special_Moves")

Guard = Creature("Guard", 1, "1x1", 4, "Human", "Flesh", "Dumb Idiot", "Attacks", "Spear", "Dagger", None, "Chain Mail", "Combat_Special_Moves", 2, 2, 2, "Immunities", "Weaknesses", "Vitals_1", "Vitals_2", "Vitals_3", "Reactions", "Combat_Role", "Tactics_1", "Tactics_2", "Tactics_3", "Value", "Needs", "Mission", "Role_Playing_Special_Moves", 30, 15, 20, 2, 5, 10, 1, 2, 1, 1, 0, 1, 2, 1, 4, 1, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "Adventuring_Special_Moves", "Adventuring_Difficulty", "Role_Playing_Difficulty", "Combat_Difficulty", "Candy", "Paprika", "Health Potion", "Ruby", "Heart of Darkness")


equip_all(Dougey)
equip_all(Guard)


Maincharacter = Dougey.Name
Guard_name = Guard.Name



print(Maincharacter, Guard_name)

print(Dougey.Max_AP)
print(Dougey.HP["Prime"])
print(Dougey.Statuses["Blinded"])
print(Dougey.Equipment["Main Hand"])

print(type(Guard))
print(Guard.visibility["Size"])
print(Dougey.Equipment)

# Dougey = PC("Dougey", "Brute", "Human", "Blue", "Skin_Tone", "Hair_Color", 1, 4, "Trademarks", 25, 15, 20, 5, 10, 15, 2, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 2, 0, 0, 1, 2, 2, 1, 0, 1, 0, 0, 0, 2, 2, 2, "Offensive_Ability", "Defensive_Ability", "Movement_Ability", "Special_Ability", "Long Sword", "Off_Hand", "Utility", "Leather Armor", "Combat_Special_Move", "Backpack", "Gold", "Rations", "Kits", "Adventuring_Special_Moves", "Value_Self", "Value_Others", "Value_Society", "Mission", "Interests", "Talents", "Quirks", "Fears", "Family", "Friends", "Professional", "Nemesis", "Factions", "Home", "Profession", "Skill", "Race_Bonus", "Story", "Roleplaying_Special_Moves")

# Guard = Creature("Guard", 1, "1x1", 4, "Human", "Flesh", "Dumb Idiot", "Attacks", "Spear", None, None, "Chain Mail", "Combat_Special_Moves", 2, 2, 2, "Immunities", "Weaknesses", "Vitals_1", "Vitals_2", "Vitals_3", "Reactions", "Combat_Role", "Tactics_1", "Tactics_2", "Tactics_3", "Value", "Needs", "Mission", "Role_Playing_Special_Moves", 30, 15, 20, 2, 5, 10, 1, 2, 1, 1, 0, 1, 2, 1, 4, 1, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, "Backpack", "Adventuring_Special_Moves", "Adventuring_Difficulty", "Role_Playing_Difficulty", "Combat_Difficulty")


combat_encounter(Dougey,Guard)


# # exec(Guard.Name + "." + actions_dict["Choke"]["Payload"])

# # Guard.suffocating_status_stage += 1
# # print(Guard.suffocating_status_stage)

# # print(Dougey.suffocating_status_stage)

# print(Guard.frightened_status_stage)

# """1.   Update PC and Creature to have positions
# 2.   update actions payloads
# 3.   update effect function to acount for different types of specialty payloads
# 4.   update weapon payloads
# 5.   create techiniques with payloads
# 6.   create features with payloads
# 7.   create status payloads and put them in pc and creature classes
# 8.   figure out combat classes and all of the junk tied to that
# 9.   severe testing for scalability. 
# 10.  add creature ai in combat roles, mortality, and creature tactics
# """

# effect(Dougey,Guard,"Taunt","Success")

# for i in actions_dict:
#   failed_actions = []
#   print(i)
#   try:
#     if actions_dict[i]["Action_Type"] == "Reaction":
#       print(i + " is a reaction")
#     elif actions_dict[i]["Action_Type"] == "Range":
#       effect(Dougey,Guard,i,15)
#     elif actions_dict[i]["Action_Type"] == "Contest":
#       effect(Dougey,Guard,i, "Success")
#     elif actions_dict[i]["Action_Type"] == "Attack":
#       effect(Dougey,Guard,i, "Success")
#     else:
#       effect(Dougey,Guard,i,"Success")
#   except:
#     print("----------" + i + " FAILED TO WORK")
#     failed_actions.append(i)

# print(failed_actions)

# total = 0
# for weapon in weapons_dict:
#   print(weapon)
#   print(weapons_dict[weapon]["Features"])
#   # if len(weapon["Feature"]) > 0:
#   #   for feature in weapon["Features"]:
#   #     print(feature)
  
#   total += 1

# print(total)

# print(weapons_dict["Maul"]["Techniques"])
# print(weapons_dict["Maul"])
